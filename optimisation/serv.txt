// Ajout dans server.js

const express = require('express');
const axios = require('axios');
const cors = require('cors');
const { exec, spawn } = require('child_process');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3001;
const SERVICE_URL = process.env.RENDER_EXTERNAL_URL || `http://localhost:${PORT}`;

// Middleware pour g√©rer la mise en veille
app.use(cors());
app.use(express.json());

// NOUVEAU: Health check endpoint
app.get('/health', (req, res) => {
    res.status(200).json({ 
        status: 'healthy', 
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage()
    });
});

// NOUVEAU: Endpoint de r√©veil
app.get('/wake', (req, res) => {
    console.log('Wake-up call received at:', new Date().toISOString());
    res.status(200).json({ 
        status: 'awake', 
        message: 'Service is running',
        timestamp: new Date().toISOString()
    });
});

// NOUVEAU: Syst√®me keep-alive interne
class KeepAliveManager {
    constructor() {
        this.isProduction = process.env.NODE_ENV === 'production';
        this.pingInterval = 14 * 60 * 1000; // 14 minutes (avant les 15 min de Render)
        this.maxRetries = 3;
        this.currentRetries = 0;
        
        if (this.isProduction && SERVICE_URL.includes('render')) {
            this.startKeepAlive();
        }
    }

    async pingSelf() {
        try {
            console.log('üèÉ Keep-alive ping at:', new Date().toISOString());
            const response = await axios.get(`${SERVICE_URL}/wake`, {
                timeout: 10000,
                headers: { 'User-Agent': 'KeepAlive-Bot' }
            });
            
            console.log('‚úÖ Keep-alive successful:', response.data);
            this.currentRetries = 0; // Reset counter on success
            
        } catch (error) {
            this.currentRetries++;
            console.error(`‚ùå Keep-alive failed (attempt ${this.currentRetries}/${this.maxRetries}):`, error.message);
            
            if (this.currentRetries >= this.maxRetries) {
                console.error('üö® Keep-alive failed after maximum retries');
                // Optionnel: envoyer une notification ou log d'erreur
            }
        }
    }

    startKeepAlive() {
        console.log('üîÑ Starting keep-alive system...');
        console.log(`üì° Will ping ${SERVICE_URL}/wake every ${this.pingInterval / 1000 / 60} minutes`);
        
        // Ping imm√©diat pour v√©rifier que √ßa marche
        this.pingSelf();
        
        // Puis ping r√©gulier
        setInterval(() => {
            this.pingSelf();
        }, this.pingInterval);
    }
}

// Initialiser le keep-alive
const keepAlive = new KeepAliveManager();

// NOUVEAU: Gestion de cache avec headers optimis√©s
app.use((req, res, next) => {
    // Pour les ressources statiques
    if (req.url.match(/\.(js|css|png|jpg|jpeg|gif|ico|svg)$/)) {
        res.set({
            'Cache-Control': 'public, max-age=31536000', // 1 an
            'Expires': new Date(Date.now() + 31536000000).toUTCString()
        });
    }
    
    // Pour les API calls
    if (req.url.startsWith('/api/') || req.url.startsWith('/proxy') || req.url.startsWith('/predict-')) {
        res.set({
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0'
        });
    }
    
    next();
});

// NOUVEAU: Compression pour r√©duire la taille des r√©ponses
const compression = require('compression');
app.use(compression({
    filter: (req, res) => {
        // Compresser tout sauf les images d√©j√† compress√©es
        if (req.headers['x-no-compression']) {
            return false;
        }
        return compression.filter(req, res);
    },
    level: 6, // Niveau de compression √©quilibr√©
    threshold: 1024 // Compresser seulement si > 1KB
}));

// Route proxy optimis√©e avec cache
const responseCache = new Map();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

app.get('/proxy', async (req, res) => {
    const targetUrl = req.query.url;
    if (!targetUrl) {
        return res.status(400).json({ error: 'Le param√®tre "url" est manquant' });
    }

    // V√©rifier le cache
    const cacheKey = targetUrl;
    const cached = responseCache.get(cacheKey);
    
    if (cached && (Date.now() - cached.timestamp) < CACHE_DURATION) {
        console.log('üì¶ R√©ponse servie depuis le cache pour:', targetUrl);
        return res.json(cached.data);
    }

    try {
        console.log('üåê Fetching from source:', targetUrl);
        const response = await axios.get(targetUrl, {
            timeout: 15000, // 15 secondes timeout
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept-Encoding': 'gzip, deflate, br',
                'Accept': 'application/json, text/plain, */*'
            }
        });

        // Mettre en cache la r√©ponse
        responseCache.set(cacheKey, {
            data: response.data,
            timestamp: Date.now()
        });

        // Nettoyer le cache p√©riodiquement
        if (responseCache.size > 100) {
            const now = Date.now();
            for (const [key, value] of responseCache.entries()) {
                if (now - value.timestamp > CACHE_DURATION) {
                    responseCache.delete(key);
                }
            }
        }

        res.json(response.data);
        
    } catch (error) {
        console.error('Proxy error for', targetUrl, ':', error.message);
        res.status(error.response?.status || 500).json({
            error: 'Impossible de r√©cup√©rer les donn√©es depuis la source distante.',
            details: error.message
        });
    }
});

// Route predict-dutching optimis√©e (votre code existant + am√©liorations)
app.post('/predict-dutching', (req, res) => {
    const startTime = Date.now();
    const { strategie, cotes, indices_forme, gains_par_course } = req.body;

    // Validation avec r√©ponse rapide
    if (!strategie || !cotes || !indices_forme || !gains_par_course) {
        return res.status(400).json({ error: 'Donn√©es manquantes pour la pr√©diction.' });
    }
    if (cotes.length !== strategie || indices_forme.length !== strategie || gains_par_course.length !== strategie) {
        return res.status(400).json({ error: 'Incoh√©rence dans le nombre de donn√©es fournies.' });
    }

    const pythonExecutable = process.platform === 'win32' ? 'python' : 'python3';
    const scriptPath = path.join(__dirname, 'predict_dutching.py');

    const args = [
        scriptPath,
        '-s', strategie.toString(),
        '-c', ...cotes.map(c => c.toString()),
        '-i', ...indices_forme.map(i => i.toString()),
        '-g', ...gains_par_course.map(g => g.toString())
    ];

    console.log(`‚ö° Ex√©cution pr√©diction (${Date.now() - startTime}ms):`, args.slice(1).join(' '));

    const pythonProcess = spawn(pythonExecutable, args, {
        timeout: 30000 // Timeout de 30 secondes
    });

    let stdout = '';
    let stderr = '';

    pythonProcess.stdout.on('data', (data) => {
        stdout += data.toString();
    });

    pythonProcess.stderr.on('data', (data) => {
        stderr += data.toString();
    });

    pythonProcess.on('close', (code) => {
        const executionTime = Date.now() - startTime;
        console.log(`‚è±Ô∏è Pr√©diction termin√©e en ${executionTime}ms (code: ${code})`);

        if (code !== 0) {
            console.error(`Script Python termin√© avec le code: ${code}`);
            console.error(`Stderr: ${stderr}`);
            return res.status(500).json({ 
                error: "Erreur lors de l'ex√©cution du script de pr√©diction.", 
                details: stderr || `Exit code: ${code}`,
                executionTime
            });
        }

        try {
            const lines = stdout.trim().split('\n');
            
            let gainLine = null;
            let decisionLine = null;
            
            for (const line of lines) {
                if (line.includes('Pr√©diction du Gain Net') || line.includes('Prediction du Gain Net')) {
                    gainLine = line;
                }
                if (line.startsWith('‚úÖ') || line.startsWith('‚ùå') || 
                    line.includes('PARIER') || line.includes('S\'ABSTENIR')) {
                    decisionLine = line;
                }
            }

            if (!gainLine || !decisionLine) {
                throw new Error('Format de sortie du script inattendu.');
            }
            
            const gainMatch = gainLine.match(/([+-]?\d+\.?\d*)\s*‚Ç¨/);
            if (!gainMatch) {
                throw new Error('Impossible d\'extraire la valeur de gain de: ' + gainLine);
            }
            
            const gainNet = parseFloat(gainMatch[1]);
            const decision = decisionLine.trim();

            res.json({
                gainNet: gainNet,
                decision: decision,
                executionTime,
                timestamp: new Date().toISOString()
            });

        } catch (parseError) {
            console.error(`Erreur de parsing: ${parseError.message}`);
            res.status(500).json({ 
                error: "Impossible d'interpr√©ter la r√©ponse du mod√®le.", 
                details: parseError.message,
                stdout: stdout,
                executionTime
            });
        }
    });

    pythonProcess.on('error', (error) => {
        const executionTime = Date.now() - startTime;
        console.error(`Erreur de processus Python: ${error.message}`);
        res.status(500).json({ 
            error: "Impossible de d√©marrer le script Python.", 
            details: error.message,
            executionTime
        });
    });
});

// Nettoyage p√©riodique du cache
setInterval(() => {
    const now = Date.now();
    let cleaned = 0;
    for (const [key, value] of responseCache.entries()) {
        if (now - value.timestamp > CACHE_DURATION) {
            responseCache.delete(key);
            cleaned++;
        }
    }
    if (cleaned > 0) {
        console.log(`üßπ Cache nettoy√©: ${cleaned} entr√©es supprim√©es`);
    }
}, 10 * 60 * 1000); // Nettoyer toutes les 10 minutes

app.listen(PORT, () => {
    console.log(`üöÄ Backend d√©marr√© sur le port ${PORT}`);
    console.log(`üîó URL du service: ${SERVICE_URL}`);
    if (process.env.NODE_ENV === 'production') {
        console.log('üõ°Ô∏è Keep-alive system activ√© pour la production');
    }
});