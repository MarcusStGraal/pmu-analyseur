:root {
    --primary-color: #007bff;
    --success-color: #28a745;
    --warning-color: #ffc107;
    --danger-color: #dc3545;
    --dark-gray: #6c757d;
    
    --bg-color: #f4f7fc;
    --card-bg-color: #ffffff;
    --text-color: #333333;
    --text-color-light: #555555;
    --text-color-subtle: #888888;
    --border-color: #d0d0d0;
    --border-color-light: #e0e0e0;
    --input-bg-color: #ffffff;
    --info-bg-color: #e9f5ff;
    --button-gradient-start: #fdfdfd;
    --button-gradient-end: #e9e9e9;

    --border-radius: 12px;
    --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

body[data-theme="dark"] {
    --primary-color: #0d8eff;
    --success-color: #32d159;
    --warning-color: #ffca2a;
    --danger-color: #ff453a;
    --dark-gray: #8e8e93;

    --bg-color: #1c1c1e;
    --card-bg-color: #2c2c2e;
    --text-color: #f2f2f7;
    --text-color-light: #c7c7cc;
    --text-color-subtle: #8e8e93;
    --border-color: #48484a;
    --border-color-light: #3a3a3c;
    --input-bg-color: #3a3a3c;
    --info-bg-color: #3a3a3c;
    --button-gradient-start: #5a5a5c;
    --button-gradient-end: #404042;
    
    --shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
}

html, body {
    height: 100%; margin: 0; padding: 0; overflow: hidden;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-color);
    display: flex; flex-direction: column; font-size: 16px;
    transition: background-color 0.3s, color 0.3s;
}

main {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px 15px 120px 15px; 
}

body.filters-tab-active main,
body.stats-tab-active main {
    overflow-y: hidden;
    padding-bottom: 0;
    display: flex;
}

.tab-content { 
    display: none; 
    width: 100%;
}
.tab-content.active { 
    display: flex; 
    flex-direction: column;
    animation: fadeIn 0.3s ease-in-out; 
}

#tab-stats.active {
    flex-grow: 1;
}

#tab-stats > .card {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    margin-bottom: 0;
    padding-bottom: 80px;
}

#tab-stats #stats-container {
    overflow-y: auto;
    flex-grow: 1;
}

.card {
    background-color: var(--card-bg-color);
    border-radius: var(--border-radius);
    padding: 16px; margin-bottom: 15px;
    box-shadow: var(--shadow);
    transition: background-color 0.3s;
}

#tab-filters > .card {
    flex-grow: 1;
    overflow-y: auto;
    margin-bottom: 0;
    padding-bottom: 150px; 
}

#tab-filters #filters-content {
    display: flex;
    flex-direction: column;
}

#filters-action-footer {
    position: fixed;
    bottom: 60px;
    left: 0;
    right: 0;
    padding: 10px 15px;
    background-color: var(--card-bg-color);
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    z-index: 999;
    display: flex;
    gap: 10px;
    transform: translateY(200%);
    transition: transform 0.3s ease-in-out;
    flex-direction: row;
    align-items: center;
}

body.filters-tab-active #filters-action-footer {
    transform: translateY(0);
}

#filters-status-message {
    text-align: center;
    font-weight: 600;
    color: var(--text-color-light);
    font-size: 0.9em;
    min-height: 1.2em;
}

body.filters-tab-active #status {
    display: none;
}

.card h2 {
    font-size: 1.2em;
    color: var(--text-color);
    text-align: center;
    margin: 0 0 20px 0; font-weight: 600;
    text-transform: uppercase; letter-spacing: 1.5px;
}

.form-group { margin-bottom: 15px; }
.form-group:last-child { margin-bottom: 0; }
.form-group label {
    display: block; margin-bottom: 6px; font-weight: 600;
    font-size: 0.9em; color: var(--text-color-light);
}

.form-group input, .form-group select {
    width: 100%; padding: 12px; border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    font-size: 1em; box-sizing: border-box;
    background-color: var(--input-bg-color);
    color: var(--text-color);
    transition: border-color 0.2s, background-color 0.2s, color 0.2s;
    font-family: inherit;
}

.date-loader-container {
    display: flex;
    align-items: center;
    gap: 8px;
}
.date-loader-container #dateInput {
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    width: 180px;
    height: 44px;
    padding: 0 12px;
    font-family: inherit;
    font-size: 1em;
    box-sizing: border-box;
    color: var(--text-color);
    background-color: var(--input-bg-color);
}
.date-loader-container #loadProgramButton {
    width: 44px;
    height: 44px;
    padding: 0;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--border-radius);
}
.date-loader-container .toggle-switch.theme-toggle {
    margin-left: auto;
}

.info-box {
    margin-top: 15px; padding: 12px;
    background-color: var(--info-bg-color);
    border-left: 4px solid var(--primary-color);
    border-radius: 4px; text-align: left;
    font-size: 0.9em; line-height: 1.5; word-wrap: break-word;
}
.info-box strong { color: var(--primary-color); }

.info-box.non-partant {
    border-left-color: var(--warning-color);
    background-color: rgba(255, 193, 7, 0.1);
}
.info-box.non-partant strong {
    color: var(--warning-color);
}

button {
    width: 100%; padding: 12px;
    background-color: var(--primary-color);
    color: white; border: none; border-radius: var(--border-radius);
    cursor: pointer; font-size: 1em; font-weight: 600;
    transition: background-color 0.2s;
    font-family: inherit;
}
button:disabled { background-color: var(--dark-gray); cursor: not-allowed; }

.btn-danger { background-color: var(--danger-color); }

.placeholder-text { color: var(--text-color-subtle); font-style: italic; padding: 20px; text-align: center; }

.bottom-nav {
    position: fixed; bottom: 0; left: 0; right: 0; z-index: 1000;
    display: flex; background-color: var(--card-bg-color);
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    transition: background-color 0.3s;
}
.nav-btn {
    flex-grow: 1; border: none; background: none; padding: 8px 5px;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    color: var(--text-color-subtle); cursor: pointer;
    transition: color 0.2s; gap: 2px;
}
.nav-btn i { font-size: 1.6em; }
.nav-btn span { font-size: 0.75em; }
.nav-btn.active { color: var(--primary-color); }

#status {
    text-align: center; font-weight: 600;
    color: var(--text-color-light);
    padding: 10px; position: fixed;
    bottom: 60px; left:0; right: 0;
    background-color: rgba(244, 247, 252, 0.9);
    backdrop-filter: blur(5px);
    border-top: 1px solid var(--border-color-light);
    transition: background-color 0.3s, color 0.3s, border-color 0.3s;
}
body[data-theme="dark"] #status {
    background-color: rgba(44, 44, 46, 0.9);
}

.form-group select, .filters-header select {
    -webkit-appearance: none; appearance: none;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    background-size: 16px 12px;
    padding-right: 2.5rem;
}
body[data-theme="dark"] .form-group select,
body[data-theme="dark"] .filters-header select {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23f2f2f7' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
}

.stats-actions {
    display: grid;
    grid-template-columns: 1fr 1fr auto;
    gap: 10px;
    margin-bottom: 15px;
}
.stats-actions .form-group {
    margin-bottom: 0;
    display: flex;
    flex-direction: column;
}
.stats-actions label {
    font-size: 0.8em;
    text-align: center;
    color: var(--text-color-subtle);
    margin-bottom: 4px;
}
.stats-actions button,
.stats-actions select,
.stats-actions .toggle-switch.button-like-toggle .slider {
    width: 100%;
    height: 48px;
    padding: 0 8px;
    background: linear-gradient(to bottom, var(--button-gradient-start) 0%, var(--button-gradient-end) 100%);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    font-weight: 600;
    font-size: 0.95em;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    color: var(--text-color);
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    transition: all 0.2s ease-in-out;
}
#send-selection-to-filters-btn {
    background: linear-gradient(to bottom, #34d399 0%, #059669 100%);
    color: white; border-color: #047857;
}

.toggle-switch.button-like-toggle {
    width: 100%;
    height: 100%;
    display: inline-block;
    position: relative;
}
.toggle-switch.button-like-toggle .slider:before {
    content: none;
}
.toggle-switch.button-like-toggle input:checked + .slider {
    background-color: var(--dark-gray);
    color: white;
    border-color: var(--dark-gray);
}
.toggle-switch.button-like-toggle .slider:after {
    content: attr(data-off);
}
.toggle-switch.button-like-toggle input:checked + .slider:after {
    content: attr(data-on);
}

.criteria-scroller-wrapper { 
    margin-bottom: 15px;
    padding-bottom: 12px;
}

#criteria-selector-container {
    display: flex;
    gap: 8px;
    overflow-x: auto;
    padding: 4px 0 8px 0;
    scrollbar-width: thin;
    scrollbar-color: var(--dark-gray) var(--input-bg-color);
}

#criteria-selector-container::-webkit-scrollbar {
    height: 8px;
    display: block;
}
#criteria-selector-container::-webkit-scrollbar-track {
    background: var(--border-color-light);
    border-radius: 4px;
}
#criteria-selector-container::-webkit-scrollbar-thumb {
    background-color: var(--dark-gray);
    border-radius: 4px;
    border: 1px solid var(--border-color-light);
}
#criteria-selector-container::-webkit-scrollbar-thumb:hover {
    background-color: var(--primary-color);
}

.criteria-chip {
    flex-shrink: 0; padding: 6px 12px; border-radius: 20px;
    background-color: var(--input-bg-color);
    color: var(--text-color-light);
    font-size: 0.9em; font-weight: 500;
    border: 1px solid var(--border-color);
    cursor: pointer; transition: all 0.2s ease-in-out;
    white-space: nowrap; width: auto;
}
.criteria-chip.active {
    background-color: var(--dark-gray); color: white; border-color: var(--dark-gray);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}
.criteria-chip.dragging { opacity: 0.5; }

#stats-explorer-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: 10px;
    transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
}

.stat-card {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    padding: 8px 5px; border-radius: 8px; cursor: pointer;
    border: 1px solid var(--border-color);
    background: linear-gradient(to bottom, var(--button-gradient-start) 0%, var(--button-gradient-end) 100%);
    box-shadow: 0 2px 3px rgba(0,0,0,0.08); aspect-ratio: 1 / 1;
    transition: all 0.3s ease-in-out;
}

.stat-card.selected {
    transform: translateY(-2px); border: 3px solid var(--text-color) !important;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2); padding: 6px 3px; 
}
.stat-card.non-partant {
    opacity: 0.5; cursor: not-allowed; background: var(--input-bg-color);
}
.stat-card.non-partant .stat-card-num { text-decoration: line-through; }
.stat-card-num { font-size: 2em; font-weight: 700; color: var(--text-color); }
.stat-card-data {
    font-size: 0.8em; font-weight: 600; color: var(--text-color-light);
    margin-top: 2px; padding: 2px 6px; border-radius: 4px;
    transition: background-color 0.2s;
}
.stat-card-data:hover { background-color: rgba(0, 0, 0, 0.05); }
body[data-theme="dark"] .stat-card-data:hover { background-color: rgba(255, 255, 255, 0.05); }

#stats-explorer-grid .stat-card[class*="winner-"] {
    border-width: 2px;
    font-weight: bold;
}
#stats-explorer-grid .stat-card.winner-1 {
    background: linear-gradient(145deg, #ffd700, #f0c000);
    border-color: #DAA520;
}
#stats-explorer-grid .stat-card.winner-2 {
    background: linear-gradient(145deg, #e0e0e0, #b0b0b0);
    border-color: #a9a9a9;
}
#stats-explorer-grid .stat-card.winner-3 {
    background: linear-gradient(145deg, #cd7f32, #b8732e);
    border-color: #8B4513;
}
#stats-explorer-grid .stat-card.winner-3 .stat-card-num,
#stats-explorer-grid .stat-card.winner-3 .stat-card-data {
    color: white;
}
#stats-explorer-grid .stat-card.winner-4 {
    background: linear-gradient(145deg, #5bc0de, #46b8da);
    border-color: #31b0d5;
}
#stats-explorer-grid .stat-card.winner-4 .stat-card-num,
#stats-explorer-grid .stat-card.winner-4 .stat-card-data {
    color: white;
}
#stats-explorer-grid .stat-card.winner-5 {
    background: linear-gradient(145deg, #5cb85c, #4caf50);
    border-color: #388e3c;
}
#stats-explorer-grid .stat-card.winner-5 .stat-card-num,
#stats-explorer-grid .stat-card.winner-5 .stat-card-data {
    color: white;
}

.filters-main-header {
    margin-bottom: 20px;
}
.filters-main-header .form-group {
    margin-bottom: 0;
}

.filters-sub-header {
    display: grid;
    grid-template-columns: 1fr 70px auto;
    gap: 10px;
    margin-bottom: 20px;
    align-items: end;
}
.filters-sub-header .form-group {
    margin-bottom: 0;
}
.filters-sub-header .form-group select,
.filters-sub-header .form-group input {
    width: 100%;
    height: 41px;
    padding: 10px;
    font-size: 0.9em;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-sizing: border-box;
}
.filters-sub-header .form-group input[type="number"] {
    text-align: center;
    padding-left: 8px;
    padding-right: 8px;
}

.filter-counter {
    display: inline-block; background-color: var(--dark-gray); color: white;
    font-size: 0.8em; padding: 5px 12px; border-radius: 15px; font-weight: 600;
    transition: all 0.3s ease; opacity: 0; transform: scale(0.8); white-space: nowrap;
    text-align: center; height: 30px; line-height: 20px; box-sizing: border-box;
}
.filter-counter.visible { opacity: 1; transform: scale(1); }

#functions-list { display: flex; flex-direction: column; gap: 15px; }
.function-item {
    background-color: var(--card-bg-color);
    border: 1px solid var(--border-color-light);
    border-radius: var(--border-radius);
    padding: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    transition: all 0.3s ease-in-out;
}
.function-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 12px; cursor: pointer;
}
.function-title { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
.function-label-pill {
    font-size: 0.75em; font-weight: 700; padding: 3px 10px;
    border-radius: 12px; background-color: #e0e7ff; color: #4338ca;
    white-space: nowrap; max-width: 180px; overflow: hidden;
    text-overflow: ellipsis; text-align: center;
}
body[data-theme="dark"] .function-label-pill {
    background-color: #3b3b6e; color: #c3c1ff;
}
.function-name { font-weight: 600; font-size: 1.1em; color: var(--primary-color); }
.function-header-actions { display: flex; align-items: center; gap: 15px; }
.delete-btn { font-size: 1.2em; color: var(--danger-color); cursor: pointer; transition: transform 0.2s; }
.delete-btn:hover { transform: scale(1.2); }
.toggle-switch { position: relative; display: inline-block; width: 44px; height: 24px; }
.toggle-switch input { opacity: 0; width: 0; height: 0; }
.slider {
    position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
    background-color: #ccc; transition: .3s; border-radius: 24px;
}
.slider:before {
    position: absolute; content: ""; height: 18px; width: 18px;
    left: 3px; bottom: 3px; background-color: white;
    transition: .3s; border-radius: 50%;
}
input:checked + .slider { background-color: var(--primary-color); }
input:checked + .slider:before { transform: translateX(20px); }
.function-item.collapsed .function-controls { display: none; }
.function-item.collapsed .function-header { margin-bottom: 0; }

.function-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center; }
.function-controls .full-width-control { grid-column: 1 / -1; }
.function-controls input, .function-controls select {
    width: 100%; padding: 10px; font-size: 0.9em;
    border: 1px solid var(--border-color); border-radius: 6px; box-sizing: border-box;
}
.spinner-control {
    display: flex; align-items: center; justify-content: space-between;
    border: 1px solid var(--border-color); border-radius: 6px; padding: 0;
}
.spinner-control input {
    text-align: center; border: none; outline: none; padding: 8px 4px;
    width: 100%; -moz-appearance: textfield; background: none; color: var(--text-color);
}
.spinner-control input::-webkit-outer-spin-button, .spinner-control input::-webkit-inner-spin-button {
    -webkit-appearance: none; margin: 0;
}
.spinner-btn {
    background-color: var(--button-gradient-end); border: none; cursor: pointer;
    font-size: 1.2em; font-weight: bold; width: 35px; height: 38px;
    color: var(--text-color-light); transition: background-color 0.2s;
}
.spinner-btn.minus { border-right: 1px solid var(--border-color); border-radius: 5px 0 0 5px; }
.spinner-btn.plus { border-left: 1px solid var(--border-color); border-radius: 0 5px 5px 0; }
.spinner-btn:hover { background-color: var(--border-color); }

.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.6); display: flex;
    align-items: center; justify-content: center;
    z-index: 2000; backdrop-filter: blur(5px);
}
.modal-content {
    background-color: var(--card-bg-color); padding: 20px;
    border-radius: var(--border-radius); width: 90%; max-width: 400px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3); text-align: center;
}
.modal-content h3 { margin-top: 0; color: var(--primary-color); }
#modal-info-text { font-size: 0.9em; color: var(--text-color-light); margin-bottom: 20px; word-wrap: break-word; }
.modal-actions { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
#modal-create-vect-btn { background-color: var(--primary-color); }
#modal-create-order-btn { background-color: var(--success-color); }
#modal-create-som-btn { background-color: var(--warning-color); color: #333; }
#modal-create-gap-btn { background-color: var(--dark-gray); }
.btn-secondary { background-color: var(--dark-gray); }

.results-display-area {
    background-color: var(--bg-color); padding: 10px;
    border-radius: var(--border-radius); min-height: 100px; margin-top: 15px;
}
.results-display-area.grid-view {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 8px; text-align: center;
}
.results-display-area.grid-view span {
    background: linear-gradient(to bottom, var(--button-gradient-start) 0%, var(--button-gradient-end) 100%);
    border: 1px solid var(--border-color); padding: 8px 4px; border-radius: 8px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.08); font-family: monospace;
    color: var(--text-color); font-weight: 600;
}
.results-display-area.list-view { font-family: monospace; display: flex; flex-direction: column; gap: 5px; }
.champ-reduit-group {
    display: flex; align-items: center; gap: 8px;
    background-color: var(--card-bg-color); padding: 8px;
    border-radius: 6px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.champ-reduit-group .separator { color: var(--text-color-subtle); }
.results-options { display: flex; justify-content: center; align-items: center; margin-top: 15px;}
.results-options label { display: flex; align-items: center; gap: 8px; cursor: pointer; }
#results-header { text-align: center; display: block; margin-bottom: 10px; }#modal-create-vect-btn { background-color: var(--primary-color); }
#modal-create-order-btn { background-color: var(--success-color); }
.btn-secondary { background-color: var(--dark-gray); }

.results-display-area {
    background-color: var(--bg-color); padding: 10px;
    border-radius: var(--border-radius); min-height: 100px; margin-bottom: 15px;
}
.results-display-area.grid-view {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 8px; text-align: center;
}
.results-display-area.grid-view span {
    background: linear-gradient(to bottom, var(--button-gradient-start) 0%, var(--button-gradient-end) 100%);
    border: 1px solid var(--border-color); padding: 8px 4px; border-radius: 8px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.08); font-family: monospace;
    color: var(--text-color); font-weight: 600;
}
.results-display-area.list-view { font-family: monospace; display: flex; flex-direction: column; gap: 5px; }
.champ-reduit-group {
    display: flex; align-items: center; gap: 8px;
    background-color: var(--card-bg-color); padding: 8px;
    border-radius: 6px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.champ-reduit-group .separator { color: var(--text-color-subtle); }
.results-options { display: flex; justify-content: center; align-items: center; }
.results-options label { display: flex; align-items: center; gap: 8px; cursor: pointer; }

body.is-loading main {
    opacity: 0.6; pointer-events: none; transition: opacity 0.3s ease;
}

.results-display-area.grid-view span,
.results-display-area.list-view .champ-reduit-group {
    animation: resultFadeIn 0.5s ease forwards; opacity: 0;
}

@keyframes resultFadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.quinte-option {
    color: var(--danger-color);
    font-weight: bold;
}

.toggle-switch.theme-toggle {
    width: 60px;
    height: 30px;
}
.toggle-switch.theme-toggle .slider {
    border-radius: 30px;
    background-color: var(--primary-color);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 5px;
    box-sizing: border-box;
}
.toggle-switch.theme-toggle .slider:before {
    height: 22px;
    width: 22px;
    left: 4px;
    bottom: 4px;
    border-radius: 50%;
    transition: .4s;
}
.toggle-switch.theme-toggle input:checked + .slider {
    background-color: var(--dark-gray);
}
.toggle-switch.theme-toggle input:checked + .slider:before {
    transform: translateX(30px);
}
.toggle-switch.theme-toggle .slider i {
    color: white;
    font-size: 14px;
    transition: opacity 0.4s;
}
.toggle-switch.theme-toggle .slider .fa-sun {
    opacity: 0;
}
.toggle-switch.theme-toggle .slider .fa-moon {
    opacity: 1;
}
.toggle-switch.theme-toggle input:checked + .slider .fa-sun {
    opacity: 1;
}
.toggle-switch.theme-toggle input:checked + .slider .fa-moon {
    opacity: 0;
}

.toggle-switch.analysis-toggle {
    width: 60px;
    height: 30px;
}
.toggle-switch.analysis-toggle .slider {
    border-radius: 30px;
    background-color: var(--dark-gray);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 5px;
    box-sizing: border-box;
}
.toggle-switch.analysis-toggle .slider:before {
    height: 22px;
    width: 22px;
    left: 4px;
    bottom: 4px;
    border-radius: 50%;
    transition: .4s;
}
.toggle-switch.analysis-toggle input:checked + .slider {
    background-color: var(--primary-color);
}
.toggle-switch.analysis-toggle input:checked + .slider:before {
    transform: translateX(30px);
}
.toggle-switch.analysis-toggle .slider i {
    color: white;
    font-size: 14px;
    transition: opacity 0.4s;
}
.toggle-switch.analysis-toggle .slider .fa-brain {
    opacity: 0;
}
.toggle-switch.analysis-toggle .slider .fa-bolt {
    opacity: 1;
}
.toggle-switch.analysis-toggle input:checked + .slider .fa-brain {
    opacity: 1;
}
.toggle-switch.analysis-toggle input:checked + .slider .fa-bolt {
    opacity: 0;
}

.profile-manager-form {
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
    margin-bottom: 15px;
}
@media (min-width: 400px) {
    .profile-manager-form { grid-template-columns: 1fr 1fr; }
}

.criteria-list-container {
    max-height: 250px;
    overflow-y: auto;
    border: 1px solid var(--border-color-light);
    border-radius: var(--border-radius);
    padding: 10px;
    margin-bottom: 20px;
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
}
@media (min-width: 500px) {
    .criteria-list-container { grid-template-columns: repeat(3, 1fr); }
}

.criteria-list-container label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9em;
    cursor: pointer;
}
.criteria-list-container input[type="checkbox"] {
    width: 18px;
    height: 18px;
    flex-shrink: 0;
}

.modal-actions.profile-actions {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 8px;
    margin-bottom: 10px;
}
.modal-actions.profile-actions button {
    padding: 10px 5px;
    font-size: 0.9em;
}
#modal-cancel-profile-btn {
    margin-top: 5px;
    background-color: var(--dark-gray);
}

#tab-strategie #strategie-content {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

#strategie-race-summary {
    margin-top: 0;
    text-align: center;
    font-weight: 600;
}

#strategie-notes {
    width: 100%;
    padding: 10px;
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    font-size: 1em;
    box-sizing: border-box;
    background-color: var(--input-bg-color);
    color: var(--text-color);
    resize: vertical;
    min-height: 100px;
}

.strategie-actions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-top: 10px;
}

#filter-set-manager .form-group {
    margin-bottom: 8px;
}

#filter-set-manager .filter-set-controls {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

#filter-set-manager .filter-set-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
}

#filters-action-footer .footer-form-group {
    flex: 1;
    margin: 0 5px;
}

#filters-action-footer select,
#filters-action-footer input {
    width: 100%;
    padding: 10px;
    box-sizing: border-box;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    background-color: var(--input-bg-color);
    color: var(--text-color);
    font-size: 0.9em;
}

#filters-action-footer button {
    flex-shrink: 0;
    width: auto;
    padding: 10px 15px;
}

.distribution-horse-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-height: 40vh;
    overflow-y: auto;
    padding: 10px;
    background-color: var(--bg-color);
    border-radius: var(--border-radius);
}

.distribution-horse-item {
    display: grid;
    grid-template-columns: auto 40px 1fr auto;
    align-items: center;
    gap: 10px;
    padding: 8px;
    background-color: var(--card-bg-color);
    border-radius: 8px;
    border: 1px solid var(--border-color-light);
    cursor: pointer;
    transition: background-color 0.2s;
}

.distribution-horse-item:hover {
    background-color: var(--info-bg-color);
}

.distribution-horse-item input[type="checkbox"] {
    width: 20px;
    height: 20px;
}

.distribution-horse-item .horse-num {
    font-weight: 700;
    font-size: 1.1em;
    text-align: center;
}

.distribution-horse-item .horse-name {
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.distribution-horse-item .horse-cote {
    font-weight: 600;
    color: var(--primary-color);
}

.distribution-results-container {
    margin-top: 20px;
}
.distribution-results-summary {
    text-align: center;
    font-size: 1.1em;
    margin-bottom: 15px;
    padding: 10px;
    background-color: var(--info-bg-color);
    border-radius: 8px;
}

.distribution-results-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9em;
}
.distribution-results-table th,
.distribution-results-table td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid var(--border-color-light);
}
.distribution-results-table th {
    font-weight: 600;
    color: var(--text-color-light);
}
.distribution-results-table td:nth-child(2),
.distribution-results-table td:nth-child(3),
.distribution-results-table td:nth-child(4) {
    text-align: right;
    font-family: monospace;
}
.dutching-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    padding: 10px;
    border: 1px solid var(--border-color-light);
    border-radius: var(--border-radius);
    background-color: var(--bg-color);
}

.dutching-container h3 {
    text-align: center;
    color: var(--primary-color);
    margin: 0 0 5px 0;
}

.dutching-container .dutching-description {
    font-size: 0.9em;
    color: var(--text-color-light);
    text-align: center;
    margin-bottom: 10px;
    line-height: 1.4;
}

#run-dutching-analysis-btn {
    background-color: var(--success-color);
}

#dutching-results-container {
    margin-top: 15px;
}

.dutching-result-card {
    background-color: var(--card-bg-color);
    border-radius: var(--border-radius);
    padding: 15px;
    border-left: 5px solid var(--dark-gray);
    box-shadow: var(--shadow);
    animation: fadeIn 0.5s ease;
}

.dutching-result-card h3 {
    margin-top: 0;
    color: var(--text-color);
    font-size: 1.1em;
}

.dutching-result-card p {
    margin: 8px 0;
    font-size: 1em;
    color: var(--text-color-light);
}

.dutching-decision {
    margin-top: 15px;
    padding: 12px;
    font-size: 1.2em;
    font-weight: 700;
    text-align: center;
    border-radius: 8px;
    background-color: var(--bg-color);
}

.dutching-details {
    margin-top: 15px;
    font-size: 0.9em;
}

.dutching-details summary {
    cursor: pointer;
    font-weight: 600;
    color: var(--primary-color);
}

.dutching-details ul {
    list-style-type: none;
    padding-left: 10px;
    margin-top: 10px;
}
.dutching-details li {
    padding: 4px 0;
    color: var(--text-color-light);
    border-bottom: 1px solid var(--border-color-light);
}
.dutching-details li:last-child {
    border-bottom: none;
}
.dutching-applier-container {
    margin-top: 20px;
    padding: 15px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    background-color: var(--card-bg-color);
    animation: fadeIn 0.5s ease;
}

.dutching-applier-container h4 {
    text-align: center;
    margin-top: 0;
    color: var(--primary-color);
}

.horse-chips-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
    margin-bottom: 15px;
}

.horse-chip {
    background-color: var(--info-bg-color);
    color: var(--text-color);
    padding: 5px 12px;
    border-radius: 15px;
    font-size: 0.9em;
    font-weight: 600;
}

.dutching-controls {
    display: grid;
    grid-template-columns: 1fr auto 50px;
    gap: 10px;
    align-items: center;
}

.dutching-controls select, .dutching-controls input {
    height: 44px;
}

#calculate-distribution-btn {
    height: 44px;
    width: 50px;
    padding: 0;
    background-color: var(--success-color);
}
Model
Vous avez raison. Mes excuses pour la confusion. Pour plus de clarté, voici directement les fichiers complets à remplacer.
J'ai intégré toutes les modifications pour une interface plus épurée et directe comme vous l'avez demandé.
Fichier complet : frontend/js/ui.js
code
JavaScript
// js/ui.js
import { factorizeCombinations, getUniqueValuesFromGrille } from './processing.js';

function escapeHTML(unsafe) {
    if (typeof unsafe === 'number') return unsafe.toString();
    if (typeof unsafe !== 'string') return '';
    return unsafe.replace(/[&<>"']/g, match => ({'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'})[match]);
}

const DOM = {
    status: document.getElementById('status'),
    reunionSelect: document.getElementById('reunionSelect'),
    courseSelect: document.getElementById('courseSelect'),
    selectionContainer: document.getElementById('selectionContainer'),
    reunionInfoDiv: document.getElementById('reunionInfoDiv'),
    courseInfoDiv: document.getElementById('courseInfoDiv'),
    nonPartantsInfoDiv: document.getElementById('nonPartantsInfoDiv'),
    statsPlaceholder: document.getElementById('stats-placeholder'),
    statsContent: document.getElementById('stats-container'),
    statsTitle: document.getElementById('stats-title'),
    criteriaSelector: document.getElementById('criteria-selector-container'),
    statsExplorerGrid: document.getElementById('stats-explorer-grid'),
    sortToggleButton: document.getElementById('sort-toggle-btn'),
    filtersPlaceholder: document.getElementById('filters-placeholder'),
    filtersContent: document.getElementById('filters-content'),
    filtersTitle: document.getElementById('filters-title'),
    genererButton: document.getElementById('generer'),
    functionsList: document.getElementById('functions-list'),
    activeFilterCount: document.getElementById('active-filter-count'),
    resultsPlaceholder: document.getElementById('results-placeholder'),
    resultsContent: document.getElementById('results-content'),
    resultsTitle: document.getElementById('results-title'),
    resultsHeader: document.getElementById('results-header'),
    resultsWarning: document.getElementById('results-warning'),
    resultsDisplayArea: document.getElementById('results-display-area'),
    champReduitToggle: document.getElementById('champReduitToggle'),
    modal: document.getElementById('filter-action-modal'),
    modalInfoText: document.getElementById('modal-info-text'),
    sendSelectionButton: document.getElementById('send-selection-to-filters-btn'),
    filterSetManager: document.getElementById('filter-set-manager'),
    filtersStatusMessage: document.getElementById('filters-status-message'),
    criteriaProfileModal: document.getElementById('criteria-profile-modal'),
    profileSelect: document.getElementById('profile-select'),
    profileNameInput: document.getElementById('profile-name-input'),
    criteriaProfileList: document.getElementById('criteria-profile-list'),
    strategiePlaceholder: document.getElementById('strategie-placeholder'),
    strategieContent: document.getElementById('strategie-content'),
    strategieRaceSummary: document.getElementById('strategie-race-summary'),
    strategieNotes: document.getElementById('strategie-notes'),
    standardFiltersUI: document.getElementById('standard-filters-ui'),
    distributionUI: document.getElementById('distribution-ui'),
    filtersActionFooter: document.getElementById('filters-action-footer'),
    nbCombinaison: document.getElementById('nbCombinaison')
};

if (DOM.status) {
    DOM.status.setAttribute('aria-live', 'polite');
}

function updateTabTitles(state) {
    const { selectedReunionNum, selectedCourseNum, currentRaceDifficulty } = state;
    const color = currentRaceDifficulty ? currentRaceDifficulty.color : 'inherit';
    if (selectedReunionNum && selectedCourseNum) {
        const raceSuffix = ` R${selectedReunionNum}C${selectedCourseNum}`;
        if (DOM.statsTitle) {
            DOM.statsTitle.textContent = `ANALYSE${raceSuffix}`;
            DOM.statsTitle.style.color = color;
        }
        if (DOM.filtersTitle) {
            DOM.filtersTitle.textContent = `MES FILTRES${raceSuffix}`;
            DOM.filtersTitle.style.color = color;
        }
        if (DOM.resultsTitle) {
            DOM.resultsTitle.textContent = `MES TICKETS${raceSuffix}`;
            DOM.resultsTitle.style.color = color;
        }
    } else {
        if (DOM.statsTitle) DOM.statsTitle.textContent = 'Analyse des Partants';
        if (DOM.filtersTitle) DOM.filtersTitle.textContent = 'Mes Filtres';
        if (DOM.resultsTitle) DOM.resultsTitle.textContent = 'Mes Tickets';
        [DOM.statsTitle, DOM.filtersTitle, DOM.resultsTitle].forEach(el => el && (el.style.color = 'inherit'));
    }
}


export function setupNavigation() {
    document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.addEventListener('click', () => switchTab(btn.dataset.tab));
    });
    switchTab('selection');
}

export function switchTab(tabId) {
    document.body.classList.toggle('filters-tab-active', tabId === 'filters');
    document.body.classList.toggle('stats-tab-active', tabId === 'stats');
    document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tabId));
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.toggle('active', content.id === `tab-${tabId}`);
    });
}

export const EXPLORER_CRITERIA = [
    { key: 'cote', label: 'Cote', unit: '/1', format: 'float', defaultAsc: true, rankable: true },
    { key: 'indiceForme', label: 'Ind. Forme', unit: '', format: 'float', defaultAsc: true, rankable: true },
    { key: 'gainsParCourse', label: 'Gains/Crs', unit: '€', format: 'currency', defaultAsc: false, rankable: true },
    { key: 'coursesApresAbsence', label: 'Crs Rentrée', unit: '', format: 'integer', defaultAsc: false, rankable: true },
    { key: 'chevauxBattus3d', label: 'Adv. Battus', unit: '', format: 'integer', defaultAsc: false, rankable: true },
    { key: 'chevauxBattus3dPct', label: 'Adv. Battus %', unit: '%', format: 'percent', defaultAsc: false, rankable: true },
    { key: 'unite', label: 'Unité', unit: '', format: 'boolean', defaultAsc: false, rankable: true },
    { key: 'parite', label: 'Parité', unit: '', format: 'boolean', defaultAsc: false, rankable: true },
    { key: 'ecartDistance', label: 'Δ Dist. Perso', unit: '', format: 'integer', defaultAsc: true, rankable: true },
    { key: 'formeMontante', label: 'Forme Mont.', unit: '', format: 'boolean', defaultAsc: false, rankable: true },    
    { key: 'nbPlaces_3d', label: 'Podiums (3d)', unit: '', format: 'integer', defaultAsc: false, rankable: true },
    { key: 'meilleurePerfAbsolue_5d', label: 'Meilleure Perf (5d)', unit: '', format: 'integer', defaultAsc: true, rankable: true },
    { key: 'nbCoursesHippo', label: 'Nb Hippo', unit: '', format: 'integer', defaultAsc: false, rankable: true },
    { key: 'dernierePerfNorm', label: 'Dern. Perf.', unit: '', format: 'integer', defaultAsc: true, rankable: true }, 
    { key: 'evolPerf', label: 'Évol. Perf.', unit: '', format: 'integer', defaultAsc: false, rankable: true }, 
    { key: 'moyennePerfAnnee', label: 'Moy. Perf.', unit: '', format: 'float', defaultAsc: true, rankable: true }, 
    { key: 'nbCoursesCarriere', label: 'Nb Courses', unit: '', format: 'integer', defaultAsc: false, rankable: true }, 
    { key: 'influenceJockey', label: 'Infl. Jockey', unit: '', format: 'integer', defaultAsc: false, rankable: true }, 
    { key: 'influenceEntraineur', label: 'Infl. Entraîn.', unit: '', format: 'integer', defaultAsc: false, rankable: true }, 
    { key: 'influencePere', label: 'Infl. Père', unit: '', format: 'integer', defaultAsc: false, rankable: true }, 
    { key: 'poids', label: 'Poids', unit: 'kg', format: 'float', defaultAsc: false, rankable: true, disciplines: ['PLAT', 'OBSTACLE', 'TROT_MONTE'] }, 
    { key: 'valeur', label: 'Val. Hand.', unit: '', format: 'float', defaultAsc: false, rankable: true, disciplines: ['PLAT', 'OBSTACLE'] }, 
    { key: 'age', label: 'Âge', unit: ' ans', format: 'integer', defaultAsc: true, rankable: true }, 
    { key: 'sexe', label: 'Sexe', unit: '', format: 'string', defaultAsc: true },
    { key: 'corde', label: 'Corde', unit: '', format: 'integer', defaultAsc: true, rankable: true }, 
    { key: 'def', label: 'Déferré', unit: '', format: 'integer', defaultAsc: false, rankable: true }, 
    { key: 'gainsCarriere', label: 'Gains Carr.', unit: '€', format: 'currency', defaultAsc: false, rankable: true }, 
    { key: 'gainsAnneeEnCours', label: 'Gains 2025', unit: '€', format: 'currency', defaultAsc: false, rankable: true }, 
    { key: 'gainsAnneePrecedente', label: 'Gains 2024', unit: '€', format: 'currency', defaultAsc: false, rankable: true }, 
    { key: 'gainsVictoires', label: 'Gains Victoires', unit: '€', format: 'currency', defaultAsc: false, rankable: true },
    { key: 'gainsPlace', label: 'Gains Places', unit: '€', format: 'currency', defaultAsc: false, rankable: true },
    { key: 'ecartJours', label: 'Fraîcheur', unit: 'j', format: 'integer', defaultAsc: true, rankable: true }, 
    { key: 'dernierMemeHippo', label: 'Dern. Même Hippo', unit: '', format: 'boolean' }, 
    { key: 'dernierNbPartants', label: 'Dern. Nb Partants', unit: '', format: 'integer', defaultAsc: false, rankable: true }, 
    { key: 'sum_allocations_3d', label: 'Alloc. 3D', unit: '€', format: 'currency', defaultAsc: false, rankable: true }, 
    { key: 'ecartPoids', label: 'Δ Poids', unit: 'kg', format: 'integer', defaultAsc: true, rankable: true, disciplines: ['PLAT', 'OBSTACLE', 'TROT_MONTE'] }, 
    { key: 'driverChange', label: 'Chg. Driver', unit: '', format: 'boolean' }, 
    { key: 'reussiteHippo', label: 'Tx Hippo', unit: '%', format: 'percent', defaultAsc: false, rankable: true }, 
    { key: 'reussiteDistance', label: 'Tx Dist.', unit: '%', format: 'percent', defaultAsc: false, rankable: true }, 
    { key: 'oeilleres', label: 'Œillères', unit: '', format: 'string', defaultAsc: true }, 
    { key: 'lettre_1', label: 'Lettre 1', unit: '', format: 'string', defaultAsc: true }, 
    { key: 'lettre_2', label: 'Lettre 2', unit: '', format: 'string', defaultAsc: true },
    { key: 'recordVitesseHippo', label: 'Record Hippo', unit: 's', format: 'float', defaultAsc: true, rankable: true, disciplines: ['TROT_ATTELE', 'TROT_MONTE'] },
    { key: 'rkAdjusted', label: 'RK Ajustée', unit: '', format: 'integer', defaultAsc: true, rankable: true, disciplines: ['TROT_ATTELE', 'TROT_MONTE'] },
    { key: 'dernierReducKm', label: 'Dern. Réduc. Km', unit: '', format: 'string', defaultAsc: true, rankable: true, disciplines: ['TROT_ATTELE', 'TROT_MONTE'] },    
    { key: 'recordVitessePlatHippo', label: 'Record Vitesse', unit: 'm/s', format: 'float', defaultAsc: false, rankable: true, disciplines: ['PLAT', 'GALOP', 'OBSTACLE'] },
];

const FILTER_FUNCTION_COLUMNS = [
    { value: 'num', label: 'N°' }, { value: 'age', label: 'Age' }, { value: 'sexe', label: 'Sexe' }, { value: 'poids', label: 'Poids' }, { value: 'corde', label: 'Corde' }, { value: 'valeur', label: 'Val.Hand.' }, { value: 'cote', label: 'Cotes' }, { value: 'gainsCarriere', label: 'Gains' }, { value: 'gainsVictoires', label: 'Gains Victoires' }, { value: 'gainsPlace', label: 'Gains Places' }, { value: 'def', label: 'Déferré' }, { value: 'dernierePerfNorm', label: 'Dern. Perf' }, { value: 'evolPerf', label: 'Évol. Perf' }, { value: 'moyennePerfAnnee', label: 'Moy. Perf' }, { value: 'nbCoursesCarriere', label: 'Nb Courses' }, { value: 'dernierReducKm', label: 'Dern. Réduc. Km' }, { value: 'dernierMemeHippo', label: 'Dern. Même Hippo' }, { value: 'dernierNbPartants', label: 'Dern. Nb Partants' }, { value: 'influenceJockey', label: 'Infl. Jockey' }, { value: 'influenceEntraineur', label: 'Infl. Entraîn.' }, { value: 'influencePere', label: 'Infl. Père' },
    { value: 'nbPlaces_3d', label: 'Nb Podiums (3d)'}, { value: 'meilleurePerfAbsolue_5d', label: 'Meilleure Perf (5d)' },
    { value: 'rkAdjusted', label: 'RK Ajustée' }, { value: 'nbCoursesHippo', label: 'Nb Hippo' },
    { value: 'rankNbPlaces_3d', label: 'Rg Podiums (3d)'}, { value: 'rankMeilleurePerfAbsolue_5d', label: 'Rg Meilleure Perf (5d)' },
    { value: 'rankCote', label: 'Rg Cote' }, { value: 'rankGains', label: 'Rg Gains' }, { value: 'rankGainsVictoires', label: 'Rg Gains Vict.' }, { value: 'rankGainsPlace', label: 'Rg Gains Places' }, { value: 'rankPoids', label: 'Rg Poids' }, { value: 'rankValeur', label: 'Rg Valeur' }, { value: 'rankEcartJours', label: 'Rg Fraîch.' }, { value: 'rankRkAdjusted', label: 'Rg RK Ajustée' }, { value: 'rankReussiteHippo', label: 'Rg Tx Hippo' }, { value: 'rankReussiteDistance', label: 'Rg Tx Dist.' },
];

let combinationRenderTimeout = null;
let currentNumbersForModal = [];
let currentGroupNameForModal = '';

export function renderApp(state) {
    document.body.classList.toggle('is-loading', state.isLoading);
    updateStatus(state.status.message, state.status.isError);
    updateTabTitles(state);

    if (state.programmeData && state.programmeData.programme) {
        const timeZoneOffset = state.programmeData.programme.timeZoneOffset || 0;
        populateReunionSelect(state.programmeData.programme.reunions, state.selectedReunionNum, timeZoneOffset);
        showSelectionContainer();
        const selectedReunion = state.programmeData.programme.reunions.find(r => r.numOfficiel == state.selectedReunionNum);
        if(selectedReunion) {
            populateCourseSelect(selectedReunion.courses, state.selectedCourseNum, timeZoneOffset);            
            displayReunionInfo(selectedReunion);
            const selectedCourse = selectedReunion.courses.find(c => c.numExterne == state.selectedCourseNum);
            if(selectedCourse) {
                 displayCourseInfo(selectedCourse, state.currentRaceDifficulty);
            }
        }
    }

    if (state.participantsData) {
        displayNonPartantsInfo(state.participantsData);
        const activeProfile = state.criteriaProfiles.find(p => p.id === state.activeCriteriaProfileId) || state.criteriaProfiles[0];
        
        const criteriaProfileBtn = document.getElementById('criteria-profile-btn');
        if (criteriaProfileBtn && activeProfile) {
            criteriaProfileBtn.textContent = activeProfile.name;
        }

        renderStatsExplorer(state.participantsData, activeProfile, state.ui.stats.currentCriteria, state.ui.stats.sortState, state.ui.stats.manualSelection, state.participantsData.arrivalRanks, state.ui.stats.displayMode, state.isDailyAnalysisEnabled);
        updateSendSelectionButton(state.ui.stats.manualSelection);
        activateFiltersTab(true);
        renderFiltersContent(state);
    } else {
        renderStatsExplorer(null);
        activateFiltersTab(false);
        renderFiltersContent(state);
    }

    updateFunctionsList(state.filters, state.participantsData);
    renderStrategieTab(state);
    
    if (DOM.criteriaProfileModal) {
        if (state.ui.isCriteriaModalOpen) {
            const discipline = state.participantsData ? state.participantsData.discipline : null;
            renderCriteriaProfileModal(state.criteriaProfiles, state.ui.criteriaModal, discipline);
            DOM.criteriaProfileModal.style.display = 'flex';
        } else {
            DOM.criteriaProfileModal.style.display = 'none';
        }
    }

    const { combinations, betName, betType, limitReached, showChampReduit } = state.results;
    if (DOM.champReduitToggle) DOM.champReduitToggle.checked = showChampReduit;
    if (DOM.nbCombinaison) DOM.nbCombinaison.value = betType;

    updateResultsTab(combinations.length, betName, betType, limitReached);
    renderCombinationsProgressively(combinations, betType, showChampReduit);
}

export function showFilterActionModal(numeros, groupName) {
    currentNumbersForModal = numeros;
    currentGroupNameForModal = groupName;
    if (DOM.modalInfoText) DOM.modalInfoText.textContent = `Créer un filtre basé sur le groupe "${escapeHTML(groupName)}" (Numéros: ${numeros.join(', ')}) ?`;
    if (DOM.modal) DOM.modal.style.display = 'flex';
}

export function hideFilterActionModal() {
    if (DOM.modal) DOM.modal.style.display = 'none';
    currentNumbersForModal = [];
    currentGroupNameForModal = '';
}

export function getCurrentModalNumbers() {
    return currentNumbersForModal;
}

export function getCurrentModalGroupName() {
    return currentGroupNameForModal;
}

export function updateStatus(message, isError = false) {
    if (!DOM.status) return;
    DOM.status.textContent = message;
    DOM.status.style.color = isError ? 'var(--danger-color)' : 'var(--text-color-light)';
}

export function updateSendSelectionButton(selection) {
    if (!DOM.sendSelectionButton) return;
    const selectionCount = Array.isArray(selection) ? selection.length : 0;
    DOM.sendSelectionButton.style.visibility = selectionCount > 0 ? 'visible' : 'hidden';
    if (selectionCount > 0) {
        const countSpan = DOM.sendSelectionButton.querySelector('span');
        if (countSpan) countSpan.textContent = selectionCount;
    }
}

export function populateReunionSelect(reunions, selectedReunionNum, timeZoneOffset) {
    if (!DOM.reunionSelect) return;
    DOM.reunionSelect.innerHTML = '<option value="" disabled>Réunion</option>';
    if (!Array.isArray(reunions)) return;

    reunions.forEach(reunion => {
        const option = document.createElement('option');
        option.value = reunion.numOfficiel;
        
        const isQuinteReunion = reunion.courses && reunion.courses.some(c => c.paris?.some(p => p.typePari === 'QUINTE_PLUS'));
        if (isQuinteReunion) {
            option.classList.add('quinte-option');
        }

        let heurePremiereCourse = '';
        if (reunion.courses && reunion.courses.length > 0) {
             const premiereCourse = [...reunion.courses].sort((a,b) => a.numOrdre - b.numOrdre)[0];
             if (premiereCourse && premiereCourse.heureDepart) {
                heurePremiereCourse = new Intl.DateTimeFormat('fr-FR', {
                    timeZone: 'Europe/Paris',
                    hour: '2-digit',
                    minute: '2-digit'
                }).format(premiereCourse.heureDepart);
             }
        }
        const textParts = [heurePremiereCourse, `R${reunion.numOfficiel}`, `- ${escapeHTML(reunion.hippodrome.libelleCourt)}`];
        option.textContent = textParts.filter(Boolean).join(' ');
        if (isQuinteReunion) {
            option.textContent += ' ★ Quinté+';
        }
        DOM.reunionSelect.appendChild(option);
    });
    DOM.reunionSelect.value = selectedReunionNum || '';
    if(!selectedReunionNum) DOM.reunionSelect.selectedIndex = 0;
    DOM.reunionSelect.disabled = false;
}

export function populateCourseSelect(courses, selectedCourseNum, timeZoneOffset) {
    if (!DOM.courseSelect) return;
    DOM.courseSelect.innerHTML = '<option value="" disabled>Course</option>';
    if (!Array.isArray(courses)) return;
    courses.forEach(course => {
        const option = document.createElement('option');
        option.value = course.numExterne;
        
        const isQuinteCourse = course.paris && course.paris.some(p => p.typePari === 'QUINTE_PLUS');
        if (isQuinteCourse) {
            option.classList.add('quinte-option');
        }

        const heure = course.heureDepart ? new Intl.DateTimeFormat('fr-FR', {
            timeZone: 'Europe/Paris',
            hour: '2-digit',
            minute: '2-digit'
        }).format(course.heureDepart) : '';

        const partantsCount = course.nombrePartants || course.nombreDeclaresPartants;
        const partantsText = partantsCount ? `${partantsCount}p` : '';
        
        let discipline = course.specialite || course.discipline;
        discipline = discipline ? discipline.replace(/TROT_|OBSTACLE/g, '') : '';
        const disciplineText = discipline ? `(${discipline})` : '';

        let courseName = course.libelle;
        if (isQuinteCourse) {
            courseName = `★ ${courseName}`;
        }
        const textParts = [heure, partantsText, `C${course.numExterne}`, disciplineText, `- ${courseName}`];
        option.textContent = textParts.filter(Boolean).join(' ');
        DOM.courseSelect.appendChild(option);
    });
    DOM.courseSelect.value = selectedCourseNum || '';
    if(!selectedCourseNum) DOM.courseSelect.selectedIndex = 0;
    DOM.courseSelect.disabled = false;
}

export function displayReunionInfo(reunion) {
    if (reunion && reunion.meteo) {
        const m = reunion.meteo;
        DOM.reunionInfoDiv.innerHTML = `<strong>Météo :</strong> ${escapeHTML(m.nebulositeLibelleLong)} (${m.temperature}°C, Vent ${m.forceVent}km/h ${escapeHTML(m.directionVent)})`;
        DOM.reunionInfoDiv.style.display = 'block';
    } else {
        DOM.reunionInfoDiv.style.display = 'none';
    }
}

export function displayCourseInfo(course, difficulty) {
    let content = '';
    if (course && course.conditions) {
        content += `<strong>Conditions :</strong> ${escapeHTML(course.conditions)}`;
    }
    if (difficulty) {
        content += `<br><strong>Indice Difficulté :</strong> <span style="color:${difficulty.color}; font-weight:bold;">${difficulty.score}/100 (${difficulty.level})</span>`;
    }

    if (content) {
        DOM.courseInfoDiv.innerHTML = content;
        DOM.courseInfoDiv.style.display = 'block';
    } else {
        DOM.courseInfoDiv.style.display = 'none';
    }
}

export function displayNonPartantsInfo(participantsData) {
    const nonPartants = participantsData.num.map((num, i) => ({
        num: num,
        nom: participantsData.nom[i],
        statut: participantsData.statut[i]
    })).filter(p => p.statut !== 'PARTANT');
    
    if (nonPartants.length > 0) {
        const npList = nonPartants.map(p => `${p.num} - ${escapeHTML(p.nom)}`).join(', ');
        DOM.nonPartantsInfoDiv.innerHTML = `<strong>Non-partant(s) :</strong> ${npList}`;
        DOM.nonPartantsInfoDiv.classList.add('non-partant');
        DOM.nonPartantsInfoDiv.style.display = 'block';
    } else {
        DOM.nonPartantsInfoDiv.style.display = 'none';
    }
}

export function showSelectionContainer() {
    if (DOM.selectionContainer) DOM.selectionContainer.style.display = 'block';
}

export function resetUI() {
    if (DOM.selectionContainer) DOM.selectionContainer.style.display = 'none';
    if (DOM.reunionSelect) {
        DOM.reunionSelect.innerHTML = '<option value="" disabled selected>Réunion</option>';
        DOM.reunionSelect.disabled = true;
    }
    resetCourseSelection();
    updateResultsTab(0, '', 0);
    updateStatus('Veuillez sélectionner une date.', false);
}

export function resetCourseSelection() {
    if (DOM.courseSelect) {
        DOM.courseSelect.innerHTML = '<option value="" disabled selected>Course</option>';
        DOM.courseSelect.disabled = true;
    }
    if (DOM.reunionInfoDiv) DOM.reunionInfoDiv.style.display = 'none';
    if (DOM.courseInfoDiv) DOM.courseInfoDiv.style.display = 'none';
    if (DOM.nonPartantsInfoDiv) DOM.nonPartantsInfoDiv.style.display = 'none';
    activateFiltersTab(false);
    renderStatsExplorer(null, null, 'cote', { by: 'num' }, [], null);
}

function populateCriteriaSelector(criteriaKey, visibleCriteria) {
    if (!DOM.criteriaSelector) return;
    
    DOM.criteriaSelector.innerHTML = visibleCriteria.map(c => `
        <button type="button" class="criteria-chip ${c.key === criteriaKey ? 'active' : ''}" data-criteria="${c.key}" draggable="true">
            ${escapeHTML(c.label)}
        </button>
    `).join('');
}

export function renderStatsExplorer(grille, activeProfile, criteriaKey, sortState, selection, arrivalRanks, displayMode = 'value', isDailyAnalysisEnabled) {
    selection = selection || [];
    arrivalRanks = arrivalRanks || {};
    const isGrilleAvailable = !!grille;

    if (DOM.statsPlaceholder) DOM.statsPlaceholder.style.display = isGrilleAvailable ? 'none' : 'block';
    if (DOM.statsContent) DOM.statsContent.style.display = isGrilleAvailable ? 'block' : 'none';

    if (!isGrilleAvailable || !activeProfile) {
        if (DOM.criteriaSelector) DOM.criteriaSelector.innerHTML = '';
        return;
    }

    const influenceKeys = ['influenceJockey', 'influenceEntraineur', 'influencePere'];
    
    const visibleCriteria = activeProfile.criteriaKeys.map(key => {
        return EXPLORER_CRITERIA.find(c => c.key === key);
    }).filter(criterion => {
        if (!criterion) return false;
        if (criterion.disciplines && !criterion.disciplines.includes(grille.discipline)) return false;
        if (!isDailyAnalysisEnabled && influenceKeys.includes(criterion.key)) return false;
        return true;
    });

    populateCriteriaSelector(criteriaKey, visibleCriteria);

    const participantsArray = grille.num.map((num, i) => {
        const participant = {};
        for (const key in grille) {
            if (grille.hasOwnProperty(key)) {
                participant[key] = grille[key][i];
            }
        }
        return participant;
    });

    const criterion = EXPLORER_CRITERIA.find(c => c.key === criteriaKey);
    const sortKey = sortState.by === 'data' ? criteriaKey : 'num';
    const sortAscending = (sortState.by === 'data' && criterion) ? criterion.defaultAsc : true;

    participantsArray.sort((a, b) => {
        const valA = a[sortKey];
        const valB = b[sortKey];
        if (valA === null || valA === '') return 1;
        if (valB === null || valB === '') return -1;
        if (criterion?.format === 'string') {
            return sortAscending ? String(valA).localeCompare(String(valB)) : String(valB).localeCompare(String(valA));
        } else {
            return sortAscending ? valA - valB : valB - valA;
        }
    });

    if (DOM.sortToggleButton) {
        const sortLabel = criterion ? criterion.label : 'N°';
        DOM.sortToggleButton.textContent = sortState.by === 'data' ? sortLabel : 'N°';
    }
    if (DOM.statsExplorerGrid) {
        DOM.statsExplorerGrid.innerHTML = buildExplorerGridHTML(participantsArray, criterion, selection, arrivalRanks, displayMode);
    }
}

export function activateFiltersTab(isActive) {
    if (DOM.filtersPlaceholder) DOM.filtersPlaceholder.style.display = isActive ? 'none' : 'block';
    if (DOM.filtersContent) DOM.filtersContent.style.display = isActive ? 'block' : 'none';
}

export function updateFunctionsList(functions, grille) {
    const activeCount = functions.filter(f => f.active !== false).length;
    if (DOM.activeFilterCount) {
        DOM.activeFilterCount.textContent = activeCount;
        DOM.activeFilterCount.classList.toggle('visible', activeCount > 0);
    }
    if (!DOM.functionsList) return;
    if (functions.length === 0) {
        DOM.functionsList.innerHTML = '<p class="placeholder-text">Ajoutez un filtre pour commencer ou chargez un ensemble.</p>';
        return;
    }

    const influenceKeys = ['influenceJockey', 'influenceEntraineur', 'influencePere'];
    const isDailyAnalysisEnabled = grille && grille.influenceJockey && grille.influenceJockey.some(v => v > 0);
    
    const availableColumns = FILTER_FUNCTION_COLUMNS.filter(c => isDailyAnalysisEnabled || !influenceKeys.includes(c.value));
    const columnOptionsHTML = availableColumns.map(c => `<option value="${c.value}">${c.label}</option>`).join('');

    DOM.functionsList.innerHTML = functions.map((filter, index) => buildFilterItemHTML(filter, index, columnOptionsHTML, grille)).join('');
}

export function updateResultsTab(combinationCount, betName, betSize, limitReached = false) {
    const hasCombinations = combinationCount > 0;
    if (DOM.resultsPlaceholder) DOM.resultsPlaceholder.style.display = hasCombinations ? 'none' : 'block';
    if (DOM.resultsContent) DOM.resultsContent.style.display = hasCombinations ? 'block' : 'none';
    
    if (DOM.resultsWarning) {
        if (hasCombinations && limitReached) {
            DOM.resultsWarning.textContent = `Limite atteinte. Seules les ${combinationCount} premières combinaisons sont affichées.`;
            DOM.resultsWarning.style.display = 'block';
        } else {
            DOM.resultsWarning.style.display = 'none';
        }
    }

    if (!hasCombinations) return;
    
    if (DOM.resultsHeader) {
        let headerText = `<strong>${combinationCount}</strong> combinaisons`;
        if (limitReached) {
            headerText += ` (limite atteinte)`;
        }
        DOM.resultsHeader.innerHTML = headerText;
    }
    
    if (DOM.resultsDisplayArea) DOM.resultsDisplayArea.innerHTML = '';
}

function renderCombinationsProgressively(combinations, betSize, useChampReduit) {
    if (combinationRenderTimeout) cancelAnimationFrame(combinationRenderTimeout);
    if (!combinations || combinations.length === 0) return;

    const displayArea = DOM.resultsDisplayArea;
    if (!displayArea) return;
    
    displayArea.className = `results-display-area ${useChampReduit ? 'list-view' : 'grid-view'}`;
    displayArea.innerHTML = '';

    const chunkSize = 100;
    let index = 0;
    
    const itemsToRender = useChampReduit ? factorizeCombinations(combinations, betSize) : combinations;

    function renderChunk() {
        const fragment = document.createDocumentFragment();
        const endIndex = Math.min(index + chunkSize, itemsToRender.length);
        const chunk = itemsToRender.slice(index, endIndex);

        const html = useChampReduit 
            ? buildListViewHTML(chunk, betSize, true)
            : buildGridViewHTML(chunk);
        
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        while(tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
        }

        displayArea.appendChild(fragment);
        index = endIndex;

        if (index < itemsToRender.length) {
            combinationRenderTimeout = requestAnimationFrame(renderChunk);
        }
    }

    requestAnimationFrame(renderChunk);
}

function formatDisplayValue(rawValue, criterion, allParticipants, isRank = false) {
    if (isRank) return rawValue;

    if (criterion.format === 'float') {
        if (typeof rawValue === 'number' && !isNaN(rawValue)) {
            rawValue = (rawValue % 1 === 0) ? rawValue.toFixed(0) : rawValue.toFixed(1);
        }
    } else {
        const numericFormats = ['currency', 'integer', 'percent'];
        if (numericFormats.includes(criterion.format)) {
            if (typeof rawValue === 'number' && !isNaN(rawValue)) {
                rawValue = Math.round(rawValue);
            }
        }
    }

    if (rawValue === null || rawValue === undefined) {
        return 'N/A';
    }

    const gainKeys = ['gainsCarriere', 'gainsAnneeEnCours', 'gainsAnneePrecedente', 'gainsParCourse', 'sum_allocations_3d', 'gainsVictoires', 'gainsPlace'];
    if (gainKeys.includes(criterion.key)) {
        const allValues = allParticipants.map(p => p[criterion.key]).filter(v => typeof v === 'number' && v !== null);
        const maxVal = Math.max(...allValues);
        if (maxVal > 0) {
            const percentage = (rawValue / maxVal) * 100;
            return `${percentage.toFixed(0)}%`;
        }
        return '0%';
    }

    switch(criterion.format) {
        case 'currency': return new Intl.NumberFormat('fr-FR', { style: 'currency', currency: 'EUR', maximumFractionDigits: 0 }).format(rawValue);
        case 'percent': return `${rawValue.toFixed(0)}${criterion.unit || ''}`;
        case 'boolean': return rawValue === 1 ? '1' : '0';
        default: return `${rawValue}${criterion.unit || ''}`;
    }
}

function buildExplorerGridHTML(participants, criterion, selection, arrivalRanks, displayMode) {
    if (!criterion) return '<p>Critère de données non valide.</p>';
    const isRankView = displayMode === 'rank' && criterion.rankable;
    const rankKey = 'rank' + criterion.key.split('_').map(part => part.charAt(0).toUpperCase() + part.slice(1)).join('');

    return participants.map((p, i) => {
        const isSelectedClass = selection.includes(p.num) ? 'selected' : '';
        const arrivalRank = arrivalRanks[p.num];
        const winnerClass = arrivalRank ? `winner-${arrivalRank}` : '';
        const isNonPartantClass = p.statut !== 'PARTANT' ? 'non-partant' : '';

        const displayKey = isRankView ? rankKey : criterion.key;
        let valueForDisplay = p[displayKey];
        const originalValue = p[criterion.key];
        
        let valueForGrouping = originalValue;
        const numericFormats = ['float', 'currency', 'integer', 'percent'];
        if (numericFormats.includes(criterion.format)) {
            if (typeof originalValue === 'number' && !isNaN(originalValue)) {
                valueForGrouping = Math.round(originalValue);
            }
        }
        
        const displayValue = formatDisplayValue(valueForDisplay, criterion, participants, isRankView);
        
        return `
            <div class="stat-card ${isSelectedClass} ${winnerClass} ${isNonPartantClass}" data-num="${p.num}">
                <span class="stat-card-num">${p.num}</span>
                <small class="stat-card-data" data-key="${criterion.key}" data-value="${valueForGrouping}">
                    ${displayValue}
                </small>
            </div>
        `;
    }).join('');
}

function buildFilterItemHTML(filter, index, baseColumnOptions, grille) {
    const isCollapsed = filter.isCollapsed ? 'collapsed' : '';
    const isChecked = filter.active !== false ? 'checked' : '';
    let controlsHtml = '';
    const columnOptions = baseColumnOptions.replace(`value="${filter.column}"`, `value="${filter.column}" selected`);
    switch(filter.name) {
        case 'VECT':
            controlsHtml = `
                <div class="full-width-control">
                    <input type="text" placeholder="Numéros ex: 1 5 8" data-field="vect" value="${escapeHTML(filter.vect || '')}">
                </div>
                ${createSpinner('min', filter.min, 'Min')}
                ${createSpinner('max', filter.max, 'Max')}
            `;
            break;
        case 'SOM': case 'ORDER': case 'KTG': case 'GAP':
            const isDisabled = (filter.vect) ? 'disabled' : '';
            controlsHtml = `<select data-field="column" class="full-width-control" ${isDisabled}>${columnOptions}</select>`;
            break;
    }
    if (filter.name !== 'VECT' && filter.name !== 'ORDER') {
         controlsHtml += createSpinner('min', filter.min, 'Min') + createSpinner('max', filter.max, 'Max');
    } else if (filter.name === 'ORDER') {
         controlsHtml += `<div class="full-width-control">${createSpinner('percentage', filter.percentage, '%')}</div>`;
    }
     if(filter.name === 'GAP' || filter.name === 'KTG') {
        const gapOptions = filter.name === 'GAP' 
            ? `<option value="1" ${filter.value === '1' ? 'selected' : ''}>Écart de 1</option><option value="2" ${filter.value === '2' ? 'selected' : ''}>Écart de 2</option>`
            : `<option value="2" ${filter.value === '2' ? 'selected' : ''}>Paire</option><option value="3" ${filter.value === '3' ? 'selected' : ''}>Brelan</option>`;
        controlsHtml += `<select data-field="value" class="full-width-control">${gapOptions}</select>`;
    }
    return `<div class="function-item ${isCollapsed}" data-index="${index}">
        <div class="function-header">
            <div class="function-title">
                <span class="function-name">${filter.name}</span>
                ${filter.label ? `<span class="function-label-pill" title="${escapeHTML(filter.label)}">${escapeHTML(filter.label)}</span>` : ''}
            </div>
            <div class="function-header-actions">
                <label class="toggle-switch">
                    <input type="checkbox" data-field="active" ${isChecked} title="Activer/Désactiver">
                    <span class="slider"></span>
                </label>
                <i class="fas fa-times delete-btn" title="Supprimer" aria-label="Supprimer le filtre"></i>
            </div>
        </div>
        <div class="function-controls">${controlsHtml}</div>
    </div>`;
}

function createSpinner(field, value, placeholder) {
    return `<div class="spinner-control">
        <button type="button" class="spinner-btn minus" aria-label="Diminuer ${placeholder}">-</button>
        <input type="number" data-field="${field}" value="${value || ''}" placeholder="${placeholder}">
        <button type="button" class="spinner-btn plus" aria-label="Augmenter ${placeholder}">+</button>
    </div>`;
}

function buildGridViewHTML(combinations) {
    return combinations.map(combo => `<span>${combo.join(' ')}</span>`).join('');
}

function buildListViewHTML(combinations, betSize, isAlreadyFactored = false) {
    const factoredResult = isAlreadyFactored ? combinations : factorizeCombinations(combinations, betSize);
    if (factoredResult.length === 0) return '';
    
    return factoredResult.map(group => {
        if (group.isFactored) {
            return `<div class="champ-reduit-group">
                       <strong>${group.base.join(' ')}</strong>
                       <span class="separator">/</span>
                       <span>${group.complements.join(' ')}</span>
                     </div>`;
        } else {
            return `<div class="champ-reduit-group"><strong>${group.base.join(' ')}</strong></div>`;
        }
    }).join('');
}

export function renderCriteriaProfileModal(profiles, modalState, discipline) {
    if (!DOM.profileSelect || !DOM.criteriaProfileList || !DOM.profileNameInput) return;
    DOM.profileSelect.innerHTML = profiles.map(p => 
        `<option value="${p.id}" ${p.id === modalState.selectedProfileId ? 'selected' : ''}>${escapeHTML(p.name)}</option>`
    ).join('');

    DOM.profileNameInput.value = modalState.currentName;

    const availableCriteria = discipline
        ? EXPLORER_CRITERIA.filter(c => !c.disciplines || c.disciplines.includes(discipline))
        : EXPLORER_CRITERIA;

    DOM.criteriaProfileList.innerHTML = availableCriteria.map(c => `
        <label title="${escapeHTML(c.label)}">
            <input type="checkbox" data-criteria-key="${c.key}" ${modalState.selectedKeys.includes(c.key) ? 'checked' : ''}>
            <span>${escapeHTML(c.label)}</span>
        </label>
    `).join('');

    const deleteBtn = document.getElementById('modal-delete-profile-btn');
    const selectedProfile = profiles.find(p => p.id === modalState.selectedProfileId);
    if (deleteBtn) {
        deleteBtn.disabled = !selectedProfile || selectedProfile.isDefault;
    }
}

function renderStrategieTab(state) {
    const isRaceSelected = !!state.participantsData;
    if (!DOM.strategiePlaceholder || !DOM.strategieContent) return;
    
    DOM.strategiePlaceholder.style.display = isRaceSelected ? 'none' : 'block';
    DOM.strategieContent.style.display = isRaceSelected ? 'block' : 'none';

    if (!isRaceSelected) return;

    const reunion = state.programmeData.programme.reunions.find(r => r.numOfficiel == state.selectedReunionNum);
    const course = reunion.courses.find(c => c.numExterne == state.selectedCourseNum);
    const partantsCount = course.nombrePartants || course.nombreDeclaresPartants || '?';
    DOM.strategieRaceSummary.innerHTML = `
        <strong>R${reunion.numOfficiel} / C${course.numExterne}</strong> - ${escapeHTML(course.libelle)}<br>
        <small>${escapeHTML((course.specialite || course.discipline).replace(/_/g, ' '))} - ${course.distance}m - ${partantsCount} partants</small>
    `;

    DOM.strategieNotes.value = state.currentRaceNote || '';

    const savedFilterSets = state.savedFilterSets;
    const selectedFilterSetId = state.selectedFilterSetId;
    const currentFiltersCount = state.filters.length;
    
    const hasSavedSets = savedFilterSets && savedFilterSets.length > 0;
    const options = hasSavedSets
        ? savedFilterSets.map(s => `<option value="${s.id}" ${s.id === selectedFilterSetId ? 'selected' : ''}>${escapeHTML(s.name)}</option>`).join('')
        : '';
    
    if (DOM.filterSetManager) {
        DOM.filterSetManager.innerHTML = `
            <div class="form-group">
                <label for="filterSetSelect">Mes Ensembles de Filtres</label>
                <div class="filter-set-controls">
                    <select id="filterSetSelect" ${!hasSavedSets ? 'disabled' : ''}>
                        <option value="">-- Choisir un ensemble --</option>
                        ${options}
                    </select>
                </div>
            </div>
            <div class="filter-set-buttons">
                <button type="button" id="saveFilterSetBtn" ${currentFiltersCount === 0 ? 'disabled' : ''} title="Sauvegarder les filtres actuels">
                    <i class="fas fa-save"></i>
                </button>
                <button type="button" id="deleteFilterSetBtn" class="btn-danger" ${!selectedFilterSetId ? 'disabled' : ''} title="Supprimer l'ensemble sélectionné">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        `;
    }
}

function renderFiltersContent(state) {
    if (!DOM.standardFiltersUI || !DOM.distributionUI) return;
    const isRaceSelected = !!state.participantsData;
    const betType = state.results.betType;
    const isSimpleBet = betType === 1;
    if (DOM.filtersActionFooter) {
        DOM.filtersActionFooter.style.display = isSimpleBet ? 'none' : 'flex';
    }
    DOM.standardFiltersUI.style.display = isSimpleBet ? 'none' : 'block';
    DOM.distributionUI.style.display = isSimpleBet ? 'block' : 'none';
    if (isRaceSelected && isSimpleBet) {
        renderDutchingOptimizer(state);
    } else if (!isRaceSelected && isSimpleBet) {
        DOM.distributionUI.innerHTML = `<p class="placeholder-text">Sélectionnez une course pour utiliser l'optimiseur.</p>`;
    }
}

function renderDutchingOptimizer(state) {
    if (!DOM.distributionUI) return;
    const { dutchingPrediction, participantsData } = state;
    let resultHTML = '';
    let applicationHTML = '';

    if (dutchingPrediction) {
        const { gainNet, decision } = dutchingPrediction;
        const isPositive = gainNet > 0;
        const gainColor = isPositive ? 'var(--success-color)' : 'var(--danger-color)';

        resultHTML = `
            <div class="dutching-result-card" style="border-left-color: ${gainColor};">
                <div class="dutching-decision">${escapeHTML(decision)}</div>
            </div>
        `;

        if (isPositive) {
            applicationHTML = renderDutchingApplication(state);
        }
    }

    DOM.distributionUI.innerHTML = `
        <div class="dutching-container">
            <div class="dutching-controls-compact">
                <select id="dutching-strategie-select" ${!participantsData ? 'disabled' : ''}>
                    <option value="2">2 Favoris</option>
                    <option value="3" selected>3 Favoris</option>
                    <option value="4">4 Favoris</option>
                </select>
                <button id="run-dutching-analysis-btn" type="button" ${!participantsData ? 'disabled' : ''}>
                    Analyser
                </button>
            </div>
            <div id="dutching-results-container">
                ${resultHTML}
            </div>
            <div id="dutching-application-ui">
                ${applicationHTML}
            </div>
        </div>
    `;
}

function renderDutchingApplication(state) {
    const { participantsData, bettingDistribution } = state;
    const { selectedHorses, mode, value, results: distResults } = bettingDistribution;
    
    if (!selectedHorses || selectedHorses.length === 0) return '';
    
    const numIndex = Object.fromEntries(participantsData.num.map((n, i) => [n, i]));
    
    const horsesHTML = selectedHorses.map(num => {
        const horse = {
            num,
            nom: participantsData.nom[numIndex[num]],
            cote: participantsData.cote[numIndex[num]]
        };
        return `<span class="horse-chip">${horse.num} (${horse.cote}/1)</span>`;
    }).join('');

    let resultsHTML = '';
    if (distResults) {
        if(distResults.error) {
            resultsHTML = `<p class="info-box non-partant">${escapeHTML(distResults.error)}</p>`;
        } else {
             resultsHTML = `
                <div class="distribution-results-summary">
                    <strong>Mise Totale : ${distResults.totalMise.toFixed(2)} €</strong>
                </div>
                <table class="distribution-results-table">
                    <thead><tr><th>N°</th><th>Mise</th><th>Gain Net</th></tr></thead>
                    <tbody>
                        ${distResults.mises.sort((a,b) => a.num - b.num).map((m, index) => `
                            <tr>
                                <td><strong>${m.num}</strong></td>
                                <td>${m.mise.toFixed(2)} €</td>
                                <td style="color: ${distResults.gainsNets[index] >= 0 ? 'var(--success-color)' : 'var(--danger-color)'};">
                                    ${distResults.gainsNets[index].toFixed(2)} €
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>`;
        }
    }

    return `
        <div class="dutching-applier-container">
            <div class="horse-chips-container">${horsesHTML}</div>
            <div class="dutching-controls">
                <select id="distribution-mode-select">
                     <option value="targetProfitSimple" ${mode === 'targetProfitSimple' ? 'selected' : ''}>Bénéfice Visé</option>
                     <option value="totalBet" ${mode === 'totalBet' ? 'selected' : ''}>Mise Totale</option>
                </select>
                <input type="number" id="distribution-value-input" value="${value}" min="1">
                <button id="calculate-distribution-btn" type="button"><i class="fas fa-calculator"></i></button>
            </div>
            <div class="distribution-results-container">${resultsHTML}</div>
        </div>
    `;
}
Fichier complet : frontend/js/state.js
code
JavaScript
// js/state.js
import { switchTab } from './ui.js';
import { handleLoadProgram, fetchParticipants, fetchDetailedPerformances, fetchDutchingPrediction } from './api.js';
import * as cache from './cache.js';
import { createGrilleFromParticipants, formatDate, calculateInfluenceScores } from './processing.js';

const initialState = {
    isLoading: false,
    status: { message: 'Veuillez sélectionner une date.', isError: false },
    isDailyAnalysisEnabled: false,
    selectedDate: null,
    selectedReunionNum: null,
    selectedCourseNum: null,
    programmeData: null,
    dailyAnalysisCache: null,
    participantsData: null,
    currentRaceDifficulty: null,
    currentRaceNote: '',
    filters: [],
    savedFilterSets: [],
    selectedFilterSetId: null,
    criteriaProfiles: [],
    activeCriteriaProfileId: null,
    dutchingPrediction: null,
    bettingDistribution: {
        mode: 'targetProfitSimple',
        value: 10,
        selectedHorses: [],
        results: null
    },
    results: {
        combinations: [],
        betType: 3,
        betName: 'Tiercé',
        limitReached: false,
        showChampReduit: false
    },
    ui: {
        stats: {
            currentCriteria: 'cote',
            sortState: { by: 'num' },
            manualSelection: [],
            displayMode: 'value'
        },
        isCriteriaModalOpen: false,
        criteriaModal: {
            selectedProfileId: null,
            currentName: '',
            selectedKeys: new Set()
        }
    }
};
class StateManager {
    constructor() {
        this._state = { ...initialState };
        this._subscribers = [];
        this.filterWorker = null;
        if (window.Worker) {
            this.filterWorker = new Worker('/js/worker.js', { type: 'module' });
            this.filterWorker.onmessage = (e) => this.setCalculationResult(e.data);
            this.filterWorker.onerror = (error) => {
                this.setState({
                    isLoading: false,
                    status: { message: `Erreur Worker : ${error.message}`, isError: true }
                });
            };
        }
    }

    async runDutchingPrediction(strategie) {
        this.setState({
            isLoading: true,
            status: { message: `Analyse de la stratégie ${strategie} favoris...` },
            dutchingPrediction: null
        });

        const { participantsData } = this._state;
        if (!participantsData) {
            this.setState({ isLoading: false, status: { message: "Aucune donnée de partant disponible.", isError: true } });
            return;
        }

        const favoris = participantsData.num
            .map((num, i) => ({
                num: num,
                cote: participantsData.cote[i],
                indiceForme: participantsData.indiceForme[i],
                gainsParCourse: participantsData.gainsParCourse[i],
                statut: participantsData.statut[i]
            }))
            .filter(p => p.statut === 'PARTANT' && p.cote !== null && p.indiceForme !== null && p.gainsParCourse !== null)
            .sort((a, b) => a.cote - b.cote)
            .slice(0, strategie);

        if (favoris.length < strategie) {
            this.setState({
                isLoading: false,
                status: { message: `Pas assez de favoris avec des données complètes (trouvés: ${favoris.length}, requis: ${strategie}).`, isError: true }
            });
            return;
        }

        const predictionData = {
            strategie: strategie,
            cotes: favoris.map(p => p.cote),
            indices_forme: favoris.map(p => p.indiceForme),
            gains_par_course: favoris.map(p => p.gainsParCourse)
        };
        
        try {
            const result = await fetchDutchingPrediction(predictionData);
            
            if (result.gainNet > 0) {
                 this.setState({
                    isLoading: false,
                    dutchingPrediction: { ...result, favoris, strategie },
                    bettingDistribution: {
                        ...initialState.bettingDistribution,
                        selectedHorses: favoris.map(f => f.num)
                    },
                    status: { message: 'Analyse de rentabilité terminée.' }
                });
            } else {
                this.setState({
                    isLoading: false,
                    dutchingPrediction: { ...result, favoris, strategie },
                    bettingDistribution: initialState.bettingDistribution,
                    status: { message: 'Analyse de rentabilité terminée.' }
                });
            }
        } catch (error) {
            this.setState({
                isLoading: false,
                status: { message: `Erreur du modèle : ${error.message}`, isError: true }
            });
        }
    }

    async saveNoteForCurrentRace(note) {
        this.setState({ currentRaceNote: note });
        const { selectedDate, selectedReunionNum, selectedCourseNum } = this._state;
        if (!selectedDate || !selectedReunionNum || !selectedCourseNum) return;
        const dateStr = formatDate(new Date(selectedDate));
        const noteId = `${dateStr}-R${selectedReunionNum}-C${selectedCourseNum}`;
        await cache.set('raceNotes', { id: noteId, note: note });
    }
    exportStrategy() {
        const state = this._state;
        if (!state.participantsData) {
            this.setState({ status: { message: "Veuillez sélectionner une course avant d'exporter.", isError: true } });
            return;
        }
        const reunion = state.programmeData.programme.reunions.find(r => r.numOfficiel == state.selectedReunionNum);
        const course = reunion.courses.find(c => c.numExterne == state.selectedCourseNum);
        const strategyData = {
            race: {
                date: state.selectedDate,
                reunionNum: state.selectedReunionNum,
                courseNum: state.selectedCourseNum,
                name: course.libelle,
                discipline: course.discipline,
                distance: course.distance,
                partants: course.nombrePartants
            },
            note: state.currentRaceNote,
            filters: state.filters
        };
        const dataStr = JSON.stringify(strategyData, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `strategie_${state.selectedDate}_R${state.selectedReunionNum}C${state.selectedCourseNum}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        this.setState({ status: { message: "Stratégie exportée." } });
    }
    async importStrategy(file) {
        if (!file) return;
        const text = await file.text();
        try {
            const data = JSON.parse(text);
            if (!data.race || !data.race.date || !data.race.reunionNum || !data.race.courseNum || !data.filters) {
                throw new Error("Fichier de stratégie invalide.");
            }
            this.setState({ status: { message: "Importation de la stratégie..." } });
            document.getElementById('dateInput').value = data.race.date;
            await this.changeDate(data.race.date);
            await this.selectReunion(data.race.reunionNum, data.race.courseNum);
            this.setState({
                filters: data.filters,
                currentRaceNote: data.note || ''
            });
            this.setState({ status: { message: "Stratégie importée avec succès." } });
            switchTab('strategie');
        } catch (error) {
            this.setState({ status: { message: `Erreur d'importation : ${error.message}`, isError: true } });
        }
    }
    loadCriteriaProfiles() {
        const savedProfilesJSON = localStorage.getItem('pmuCriteriaProfiles');
        let profiles = [];
        if (savedProfilesJSON) {
            try {
                const parsedProfiles = JSON.parse(savedProfilesJSON);
                if (Array.isArray(parsedProfiles) && parsedProfiles.length > 0) {
                    profiles = parsedProfiles;
                }
            } catch (e) {
                console.error("Erreur lors du chargement des profils, réinitialisation.", e);
            }
        }
        if (profiles.length === 0) {
            profiles = [{
                id: 'default',
                name: 'Défaut',
                isDefault: true,
                criteriaKeys: ['cote', 'dernierePerfNorm', 'ecartDistance', 'nbPlaces_3d', 'meilleurePerfAbsolue_5d', 'poids', 'valeur', 'age', 'sexe', 'gainsCarriere', 'ecartJours', 'reussiteHippo', 'reussiteDistance']
            }];
            localStorage.setItem('pmuCriteriaProfiles', JSON.stringify(profiles));
        }
        this.setState({ criteriaProfiles: profiles });
    }
    _saveCriteriaProfiles() {
        localStorage.setItem('pmuCriteriaProfiles', JSON.stringify(this._state.criteriaProfiles));
    }
     openCriteriaModal() {
        const activeProfile = this._state.criteriaProfiles.find(p => p.id === this._state.activeCriteriaProfileId) || this._state.criteriaProfiles[0];
        this.setState({
            ui: {
                ...this._state.ui,
                isCriteriaModalOpen: true,
                criteriaModal: {
                    selectedProfileId: activeProfile.id,
                    currentName: activeProfile.name,
                    selectedKeys: Array.isArray(activeProfile.criteriaKeys) ? [...activeProfile.criteriaKeys] : []
                }
            }
        });
    }
    closeCriteriaModal() {
        this.setState({ ui: { ...this._state.ui, isCriteriaModalOpen: false } });
    }
    updateCriteriaModal(newState) {
        this.setState({ ui: { ...this._state.ui, criteriaModal: { ...this._state.ui.criteriaModal, ...newState } } });
    }
    selectProfileInModal(profileId) {
        const selectedProfile = this._state.criteriaProfiles.find(p => p.id === profileId);
        if (selectedProfile) {
            this.updateCriteriaModal({
                selectedProfileId: profileId,
                currentName: selectedProfile.name,
                selectedKeys: Array.from(selectedProfile.criteriaKeys)
            });
        }
    }
    saveCriteriaProfile() {
        const { selectedProfileId, currentName, selectedKeys } = this._state.ui.criteriaModal;
        if (!currentName.trim()) {
            this.setState({ status: { message: "Le nom du profil ne peut être vide.", isError: true } });
            return;
        }
        const profiles = [...this._state.criteriaProfiles];
        const existingProfile = profiles.find(p => p.id === selectedProfileId);
        if (existingProfile && !existingProfile.isDefault) {
            existingProfile.name = currentName;
            existingProfile.criteriaKeys = selectedKeys;
        } else {
            const newProfile = {
                id: Date.now().toString(),
                name: currentName,
                criteriaKeys: selectedKeys
            };
            profiles.push(newProfile);
            this.updateCriteriaModal({ selectedProfileId: newProfile.id });
        }
        this.setState({ criteriaProfiles: profiles, status: { message: `Profil "${currentName}" sauvegardé.` } });
        this._saveCriteriaProfiles();
    }
    deleteCriteriaProfile() {
        const { selectedProfileId } = this._state.ui.criteriaModal;
        const profileToDelete = this._state.criteriaProfiles.find(p => p.id === selectedProfileId);
        if (!profileToDelete || profileToDelete.isDefault) {
            this.setState({ status: { message: "Impossible de supprimer ce profil.", isError: true } });
            return;
        }
        if (!confirm(`Voulez-vous vraiment supprimer le profil "${profileToDelete.name}" ?`)) return;
        const newProfiles = this._state.criteriaProfiles.filter(p => p.id !== selectedProfileId);
        this.setState({ criteriaProfiles: newProfiles });
        this._saveCriteriaProfiles();
        this.selectProfileInModal(newProfiles[0].id);
    }
    applyCriteriaProfile() {
        const { selectedProfileId } = this._state.ui.criteriaModal;
        this.setState({ activeCriteriaProfileId: selectedProfileId });
        this.closeCriteriaModal();
    }
    subscribe(callback) {
        this._subscribers.push(callback);
    }
    setState(newState) {
        this._state = { ...this._state, ...newState };
        this._subscribers.forEach(callback => callback(this._state));
        this.saveAppState();
    }
    getState() {
        return this._state;
    }
    saveAppState() {
        if (this._state.isLoading) return;
        const stateToSave = {
            date: this._state.selectedDate,
            reunionNum: this._state.selectedReunionNum,
            courseNum: this._state.selectedCourseNum,
            filters: this._state.filters,
            betType: this._state.results.betType,
            showChampReduit: this._state.results.showChampReduit,
            activeCriteriaProfileId: this._state.activeCriteriaProfileId,
            isDailyAnalysisEnabled: this._state.isDailyAnalysisEnabled
        };
        localStorage.setItem('pmuAppState', JSON.stringify(stateToSave));
    }
    async initialize() {
        await this.loadFilterSets();
        this.loadCriteriaProfiles(); 
        const savedStateJSON = localStorage.getItem('pmuAppState');
        let stateToLoad = null;
        let dateToLoad = new Date();
        let finalProfileId = this.getState().criteriaProfiles[0]?.id || null;
        if (savedStateJSON) {
            const savedState = JSON.parse(savedStateJSON);
            stateToLoad = savedState;
            if (savedState.date) {
                dateToLoad = new Date(savedState.date + 'T00:00:00');
            }
            const savedProfileId = savedState.activeCriteriaProfileId;
            if (this.getState().criteriaProfiles.some(p => p.id === savedProfileId)) {
                finalProfileId = savedProfileId;
            }
            this.setState({
                filters: savedState.filters || [],
                results: {
                    ...this._state.results,
                    betType: savedState.betType || 3,
                    showChampReduit: savedState.showChampReduit || false
                },
                isDailyAnalysisEnabled: savedState.isDailyAnalysisEnabled === true
            });
        }
        this.setState({ activeCriteriaProfileId: finalProfileId });
        const checkbox = document.getElementById('toggleDailyAnalysis');
        if (checkbox) checkbox.checked = this._state.isDailyAnalysisEnabled;
        const dateStr = dateToLoad.toISOString().split('T')[0];
        document.getElementById('dateInput').value = dateStr;
        await this.changeDate(dateStr, stateToLoad);
    }
    async getDailyAnalysis(date, programme) {
        this.setState({ status: { message: "Analyse de la journée en cours...", isError: false } });
        const dateStr = formatDate(date);
        const allParticipantPromises = [];
        programme.reunions.forEach(reunion => {
            reunion.courses.forEach(course => {
                const reunionId = `R${reunion.numOfficiel}`;
                const courseId = `C${course.numExterne}`;
                allParticipantPromises.push(
                    fetchParticipants(dateStr, reunionId, courseId).then(p => p?.participants || [])
                );
            });
        });
        try {
            const allRacesParticipants = await Promise.all(allParticipantPromises);
            const influenceScores = calculateInfluenceScores(allRacesParticipants);
            this.setState({
                status: { message: "Analyse de la journée terminée.", isError: false },
                dailyAnalysisCache: { influenceScores }
            });
            return { influenceScores };
        } catch (error) {
            console.error("Erreur lors de l'analyse de la journée:", error);
            this.setState({ status: { message: "Erreur lors de l'analyse.", isError: true } });
            return null;
        }
    }
    async changeDate(dateStr, stateToLoad = null) {
        this.setState({
            isLoading: true,
            status: { message: 'Chargement du programme...' },
            selectedDate: dateStr,
            programmeData: null,
            participantsData: null,
            dailyAnalysisCache: null,
            selectedReunionNum: null,
            selectedCourseNum: null,
            dutchingPrediction: null
        });
        const date = new Date(dateStr + 'T00:00:00');
        const programmeKey = `programme-${formatDate(date)}`;
        const cachedProgramme = await cache.get('apiResponses', programmeKey);
        if (cachedProgramme) {
            this.setState({
                programmeData: cachedProgramme,
                status: { message: 'Programme chargé depuis le cache.' }
            });
        }
        const freshProgramme = await handleLoadProgram(date);
        if (freshProgramme) {
            this.setState({ programmeData: freshProgramme, status: { message: 'Programme mis à jour.' } });
            await cache.set('apiResponses', { key: programmeKey, data: freshProgramme });
        }
        const programmeToUse = this.getState().programmeData;
        if (programmeToUse && programmeToUse.programme) {
            if (this._state.isDailyAnalysisEnabled) {
                await this.getDailyAnalysis(date, programmeToUse.programme);
            } else {
                this.setState({ dailyAnalysisCache: null });
            }
            if (stateToLoad && stateToLoad.reunionNum) {
                await this.selectReunion(stateToLoad.reunionNum, stateToLoad.courseNum);
            } else {
                let quinteCourse = null;
                let quinteReunion = null;
                for (const reunion of programmeToUse.programme.reunions) {
                    const course = reunion.courses.find(c => c.paris?.some(p => p.typePari === 'QUINTE_PLUS'));
                    if (course) {
                        quinteCourse = course;
                        quinteReunion = reunion;
                        break;
                    }
                }
                if (quinteReunion && quinteCourse) {
                    this.setState({ status: { message: 'Course Quinté+ détectée, chargement...' } });
                    await this.selectReunion(quinteReunion.numOfficiel, quinteCourse.numExterne);
                }
            }
        }
        this.setState({ isLoading: false });
    }
        async selectReunion(reunionNum, courseToSelect = null) {
        this.setState({
            selectedReunionNum: reunionNum,
            selectedCourseNum: null,
            participantsData: null,
            currentRaceDifficulty: null,
            dutchingPrediction: null
        });
        if (courseToSelect) {
            await this.selectCourse(courseToSelect);
        }
    }
        async selectCourse(courseNum) {
        this.setState({
            isLoading: true,
            selectedCourseNum: courseNum,
            participantsData: null,
            currentRaceDifficulty: null,
            currentRaceNote: '',
            dutchingPrediction: null,
            bettingDistribution: initialState.bettingDistribution,
            ui: { ...this._state.ui, stats: { ...initialState.ui.stats, manualSelection: [] } }
        });

        const { programmeData, selectedDate, selectedReunionNum } = this._state;
        const date = new Date(selectedDate);
        const dateStr = formatDate(date);
        const noteId = `${dateStr}-R${selectedReunionNum}-C${courseNum}`;
        const reunionId = `R${selectedReunionNum}`;
        const courseId = `C${courseNum}`;
        const participantsKey = `participants-${dateStr}-${reunionId}-${courseId}`;
        const performancesKey = `performances-${dateStr}-${reunionId}-${courseId}`;
        
        const savedNote = await cache.get('raceNotes', noteId);
        if (savedNote) {
            this.setState({ currentRaceNote: savedNote.note });
        }

        const [cachedParticipants, cachedPerformances] = await Promise.all([
            cache.get('apiResponses', participantsKey),
            cache.get('apiResponses', performancesKey)
        ]);

        if (cachedParticipants) {
            const participantsData = this.processParticipantsData(cachedParticipants, cachedPerformances);
            this.setState({
                participantsData: participantsData,
                currentRaceDifficulty: participantsData.difficultyIndex,
                status: { message: 'Partants chargés du cache.' }
            });
        }

        const [freshParticipants, freshPerformances] = await Promise.all([
            fetchParticipants(dateStr, reunionId, courseId),
            fetchDetailedPerformances(dateStr, reunionId, courseId)
        ]);

        if (freshParticipants) {
            await cache.set('apiResponses', { key: participantsKey, data: freshParticipants });
            if (freshPerformances) {
                await cache.set('apiResponses', { key: performancesKey, data: freshPerformances });
            }
            const participantsData = this.processParticipantsData(freshParticipants, freshPerformances);
            this.setState({
                participantsData: participantsData,
                currentRaceDifficulty: participantsData.difficultyIndex,
                status: { message: 'Données de la course mises à jour.' }
            });
        }
        
        this.setState({ isLoading: false });
    }

    processParticipantsData(participantsJson, performancesJson) {
        if (!participantsJson) return null;
        const { programmeData, dailyAnalysisCache, selectedReunionNum, selectedCourseNum } = this._state;
        if (this._state.isDailyAnalysisEnabled && (!dailyAnalysisCache || !dailyAnalysisCache.influenceScores)) {
            console.error("dailyAnalysisCache.influenceScores n'est pas disponible. La grille sera incomplète.");
        }
        const selectedReunionData = programmeData.programme.reunions.find(r => r.numOfficiel == selectedReunionNum);
        const selectedCourseData = selectedReunionData.courses.find(c => c.numExterne == selectedCourseNum);
        const courseContext = {
            reunionDate: selectedReunionData.dateReunion,
            discipline: selectedCourseData.specialite || selectedCourseData.discipline || '',
            distance: selectedCourseData.distance,
            hippodrome: selectedReunionData.hippodrome.libelleCourt,
            nbParticipants: participantsJson.participants.length
        };
        return createGrilleFromParticipants(
            participantsJson,
            performancesJson,
            dailyAnalysisCache ? dailyAnalysisCache.influenceScores : null,
            courseContext
        );
    }
    addFilter(filter) {
        const newFilters = [filter, ...this._state.filters];
        this.setState({ filters: newFilters });
    }
    updateFilter(index, field, value) {
        const newFilters = [...this._state.filters];
        if (newFilters[index]) {
            newFilters[index][field] = value;
            if (field === 'column' && newFilters[index].name === 'COMB') {
                newFilters[index].value = '';
            }
            this.setState({ filters: newFilters });
        }
    }
    deleteFilter(index) {
        const newFilters = this._state.filters.filter((_, i) => i !== index);
        this.setState({ filters: newFilters });
    }
    toggleFilterCollapsed(index) {
        const newFilters = [...this._state.filters];
        if (newFilters[index]) {
            newFilters[index].isCollapsed = !newFilters[index].isCollapsed;
            this.setState({ filters: newFilters });
        }
    }
    async loadFilterSets() {
        const filterSets = await cache.getAll('filterSets');
        this.setState({ savedFilterSets: filterSets || [] });
    }
    async saveCurrentFilterSet(name) {
        if (!name || !name.trim()) {
            this.setState({ status: { message: "Le nom ne peut pas être vide.", isError: true } });
            return;
        }
        if (this._state.filters.length === 0) {
            this.setState({ status: { message: "Aucun filtre à sauvegarder.", isError: true } });
            return;
        }
        const newSet = {
            id: Date.now().toString(),
            name: name.trim(),
            filters: JSON.parse(JSON.stringify(this._state.filters))
        };
        await cache.set('filterSets', newSet);
        const updatedSets = [...this._state.savedFilterSets, newSet];
        this.setState({
            savedFilterSets: updatedSets,
            selectedFilterSetId: newSet.id,
            status: { message: `Ensemble "${name}" sauvegardé.` }
        });
    }
    applyFilterSet(id) {
        if (!id) {
            this.setState({ filters: [], selectedFilterSetId: null });
            return;
        }
        const setToApply = this._state.savedFilterSets.find(s => s.id === id);
        if (setToApply) {
            const newFilters = JSON.parse(JSON.stringify(setToApply.filters));
            this.setState({
                filters: newFilters,
                selectedFilterSetId: id,
                status: { message: `Ensemble "${setToApply.name}" appliqué.` }
            });
        }
    }
    async deleteFilterSet(id) {
        if (!id) return;
        const setToDelete = this._state.savedFilterSets.find(s => s.id === id);
        if (!setToDelete) return;
        if (!confirm(`Voulez-vous vraiment supprimer l'ensemble "${setToDelete.name}" ?`)) {
            return;
        }
        await cache.deleteItem('filterSets', id);
        const updatedSets = this._state.savedFilterSets.filter(s => s.id !== id);
        this.setState({
            savedFilterSets: updatedSets,
            selectedFilterSetId: this._state.selectedFilterSetId === id ? null : this._state.selectedFilterSetId,
            status: { message: `Ensemble "${setToDelete.name}" supprimé.` }
        });
    }
    runCalculation(betType, betName, limit) {
        if (!this._state.participantsData || !this.filterWorker) return;
        this.setState({
            isLoading: true,
            status: { message: 'Calcul déporté en arrière-plan...' },
            results: { ...this._state.results, betType, betName }
        });
        this.filterWorker.postMessage({
            grille: this._state.participantsData,
            functions: this._state.filters,
            betType: betType,
            limit: limit
        });
    }
    setCalculationResult(data) {
        if (data.status === 'success') {
            const { combinations, limitReached } = data;
            const newResults = { ...this._state.results, combinations, limitReached };
            let statusMessage = `Calcul terminé. ${combinations.length} combinaisons trouvées.`;
            if (limitReached) statusMessage += " La limite a été atteinte.";
            this.setState({
                isLoading: false,
                results: newResults,
                status: { message: statusMessage }
            });
            if (combinations.length > 0) {
                switchTab('results');
            }
        } else {
            this.setState({
                isLoading: false,
                status: { message: `Erreur de calcul : ${data.message}`, isError: true }
            });
        }
    }
    updateStatsUI(newStatsState) {
        this.setState({ ui: { ...this._state.ui, stats: { ...this._state.ui.stats, ...newStatsState } } });
    }
    toggleChampReduit(isChecked) {
        this.setState({ results: { ...this._state.results, showChampReduit: isChecked } });
    }
    updateBettingDistribution(newState) {
        this.setState({
            bettingDistribution: {
                ...this._state.bettingDistribution,
                ...newState,
                results: null
            }
        });
    }
    calculateBettingDistribution() {
        const { participantsData, bettingDistribution } = this._state;
        const { mode, value, selectedHorses } = bettingDistribution;
        if (!participantsData || selectedHorses.length === 0) {
            this.setState({ status: { message: "Veuillez sélectionner au moins un cheval.", isError: true } });
            return;
        }
        const numIndex = Object.fromEntries(participantsData.num.map((n, i) => [n, i]));
        const selection = selectedHorses
            .map(num => ({
                num,
                cote: participantsData.cote[numIndex[num]]
            }))
            .filter(h => h.cote && h.cote > 1 && participantsData.statut[numIndex[h.num]] === 'PARTANT');
        if (selection.length === 0) {
            this.setState({ status: { message: "Aucun cheval sélectionné avec une cote valide.", isError: true } });
            return;
        }
        let mises = [];
        let totalMise = 0;
        let error = null;
        if (mode === 'totalBet') {
            const miseTotale = Math.floor(value);
            const inverseSum = selection.reduce((sum, h) => sum + (1 / h.cote), 0);
            if (inverseSum > 0) {
                let betsWithFraction = selection.map(h => {
                    const rawMise = (miseTotale * (1 / h.cote)) / inverseSum;
                    return {
                        num: h.num,
                        cote: h.cote,
                        mise: Math.floor(rawMise),
                        fraction: rawMise - Math.floor(rawMise)
                    };
                });
                let currentTotal = betsWithFraction.reduce((sum, b) => sum + b.mise, 0);
                let remainder = miseTotale - currentTotal;
                betsWithFraction.sort((a, b) => b.fraction - a.fraction);
                for (let i = 0; i < remainder; i++) {
                    betsWithFraction[i].mise += 1;
                }
                mises = betsWithFraction.map(({num, cote, mise}) => ({num, cote, mise}));
                totalMise = mises.reduce((sum, m) => sum + m.mise, 0);
            }
        } else { // 'targetProfitSimple' or 'targetProfitExact'
            const beneficeVise = value;
            if (mode === 'targetProfitSimple') {
                mises = selection.map(h => {
                    const mise = Math.ceil(beneficeVise / (h.cote - 1));
                    return { num: h.num, cote: h.cote, mise };
                });
            } else { // 'targetProfitExact'
                const sumInverseCotes = selection.reduce((sum, h) => sum + (1 / h.cote), 0);
                if (sumInverseCotes >= 1) {
                    error = "Impossible de garantir un bénéfice avec ces cotes (somme des inverses >= 1).";
                } else {
                    const gainCible = beneficeVise / (1 - sumInverseCotes);
                    mises = selection.map(h => {
                        const mise = Math.ceil(gainCible / h.cote);
                        return { num: h.num, cote: h.cote, mise };
                    });
                }
            }
            if(!error) totalMise = mises.reduce((sum, m) => sum + m.mise, 0);
        }
        if (error) {
             this.setState({
                status: { message: error, isError: true },
                bettingDistribution: { ...bettingDistribution, results: { error } }
             });
        } else {
            const results = {
                mises,
                totalMise,
                gainsBruts: mises.map(m => m.mise * m.cote),
                gainsNets: mises.map(m => (m.mise * m.cote) - totalMise)
            };
            this.setState({
                status: { message: `Calcul de répartition terminé. Mise totale: ${results.totalMise}€` },
                bettingDistribution: { ...bettingDistribution, results }
            });
        }
    }
}
export const stateManager = new StateManager();
Fichier complet : frontend/js/main.js
code
JavaScript
// js/main.js
import { stateManager } from './state.js';
import * as cache from './cache.js';
import { renderApp, setupNavigation, showFilterActionModal, hideFilterActionModal, getCurrentModalNumbers, getCurrentModalGroupName, EXPLORER_CRITERIA, switchTab } from './ui.js';

function handleCreateFilterFromModal(type) {
    const numbers = getCurrentModalNumbers();
    if (numbers.length === 0) return;

    const groupName = getCurrentModalGroupName() || 'Sélection';
    const { currentCriteria } = stateManager.getState().ui.stats;
    
    stateManager.getState().filters.forEach(f => f.isCollapsed = true);

    let newFilter;
    if (type === 'VECT') {
        newFilter = { name: 'VECT', active: true, vect: numbers.join(' '), min: '1', max: '1', isCollapsed: false, label: groupName };
    } else if (type === 'ORDER') {
        newFilter = { name: 'ORDER', active: true, percentage: '50', column: currentCriteria, vect: numbers.join(' '), isCollapsed: false, label: groupName };
    } else if (type === 'SOM') {
        newFilter = { name: 'SOM', active: true, column: currentCriteria, min: '', max: '', isCollapsed: false, label: groupName };
    } else if (type === 'GAP') {
        newFilter = { name: 'GAP', active: true, column: currentCriteria, min: '', max: '', isCollapsed: false, label: groupName };
    }
    
    stateManager.addFilter(newFilter);
    switchTab('filters');
    hideFilterActionModal();
}

function setupTheme() {
    const themeToggleCheckbox = document.getElementById('theme-toggle-checkbox');
    if (!themeToggleCheckbox) return;
    
    const applyTheme = (theme) => {
        if (theme === 'dark') {
            document.body.dataset.theme = 'dark';
            themeToggleCheckbox.checked = true;
        } else {
            document.body.dataset.theme = 'light';
            themeToggleCheckbox.checked = false;
        }
        localStorage.setItem('pmuTheme', theme);
    };

    const savedTheme = localStorage.getItem('pmuTheme') || 'light';
    applyTheme(savedTheme);

    themeToggleCheckbox.addEventListener('change', () => {
        const newTheme = themeToggleCheckbox.checked ? 'dark' : 'light';
        applyTheme(newTheme);
    });
}

document.addEventListener('DOMContentLoaded', () => {
    cache.cleanup().then(() => console.log("Nettoyage du cache terminé."));
    setupNavigation();
    setupTheme();
    stateManager.subscribe(renderApp);
    connectEventListeners();
    stateManager.initialize();
});

function connectEventListeners() {
    const addListener = (id, event, handler) => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener(event, handler);
        }
    };

    addListener('loadProgramButton', 'click', () => {
        const dateVal = document.getElementById('dateInput').value;
        if (dateVal) stateManager.changeDate(dateVal);
    });
    addListener('toggleDailyAnalysis', 'change', e => {
        stateManager.setState({ isDailyAnalysisEnabled: e.target.checked });
        const dateVal = document.getElementById('dateInput').value;
        if (dateVal) stateManager.changeDate(dateVal);
    });
    addListener('reunionSelect', 'change', e => stateManager.selectReunion(e.target.value));
    addListener('courseSelect', 'change', e => stateManager.selectCourse(e.target.value));

    const statsContainer = document.getElementById('stats-container');
    if (statsContainer) {
        statsContainer.addEventListener('click', e => {
            if (e.target.closest('#criteria-profile-btn')) {
                stateManager.openCriteriaModal();
                return;
            }
            const criteriaChip = e.target.closest('.criteria-chip');
            if (criteriaChip) {
                stateManager.updateStatsUI({ currentCriteria: criteriaChip.dataset.criteria });
                return;
            }
            const card = e.target.closest('.stat-card');
            if (card && !card.classList.contains('non-partant')) {
                if (e.target.closest('.stat-card-data')) {
                    const dataElement = e.target.closest('.stat-card-data');
                    const clickedValue = dataElement.dataset.value;
                    const key = dataElement.dataset.key;
                    if (clickedValue === 'null' || clickedValue === 'undefined' || clickedValue === 'N/A') return;
                    const participantsData = stateManager.getState().participantsData;
                    const criterion = EXPLORER_CRITERIA.find(c => c.key === key);
                    if (!criterion || !participantsData) return;
                    const groupName = `${criterion.label} = ${clickedValue}`;
                    const numericFormats = ['float', 'currency', 'integer', 'percent'];
                    let matchingNumbers = participantsData.num.filter((num, i) => {
                        const originalValue = participantsData[key][i];
                        let comparableValue = (numericFormats.includes(criterion.format) && typeof originalValue === 'number' && !isNaN(originalValue)) ? Math.round(originalValue) : originalValue;
                        return String(comparableValue) === String(clickedValue) && participantsData.statut[i] === 'PARTANT';
                    });
                    if (matchingNumbers.length > 0) showFilterActionModal(matchingNumbers, groupName);
                } else { 
                    const num = parseInt(card.dataset.num, 10);
                    const currentSelection = [...stateManager.getState().ui.stats.manualSelection];
                    const index = currentSelection.indexOf(num);
                    if (index > -1) currentSelection.splice(index, 1); else currentSelection.push(num);
                    stateManager.updateStatsUI({ manualSelection: currentSelection });
                }
            } else if (!card) {
                if (stateManager.getState().ui.stats.manualSelection.length > 0) {
                    stateManager.updateStatsUI({ manualSelection: [] });
                }
            }
        });
    }
    addListener('send-selection-to-filters-btn', 'click', () => {
        const { manualSelection, currentCriteria } = stateManager.getState().ui.stats;
        if (manualSelection.length > 0) {
            const criterion = EXPLORER_CRITERIA.find(c => c.key === currentCriteria);
            const groupName = criterion ? `Sélection (${criterion.label})` : 'Sélection Manuelle';
            showFilterActionModal(manualSelection, groupName);
        }
    });
    addListener('sort-toggle-btn', 'click', () => {
        const currentSort = stateManager.getState().ui.stats.sortState.by;
        stateManager.updateStatsUI({ sortState: { by: currentSort === 'num' ? 'data' : 'num' } });
    });
    
    addListener('fonction', 'change', e => {
        const filterName = e.target.value;
        if (!filterName) return;
        stateManager.getState().filters.forEach(f => f.isCollapsed = true);
        const newFilter = { name: filterName, active: true, isCollapsed: false };
        if (filterName === 'VECT') { newFilter.min = '1'; newFilter.max = '1'; }
        if (filterName === 'SOM' || filterName === 'GAP') { newFilter.column = 'num'; }
        if (filterName === 'ORDER') { newFilter.percentage = '50'; newFilter.column = 'rankCote'; }
        stateManager.addFilter(newFilter);
        e.target.value = '';
    });
    
    document.body.addEventListener('click', e => {
        if (e.target.id === 'generer') {
            const betSelect = document.getElementById('nbCombinaison');
            const limitInput = document.getElementById('limitInput');
            if (betSelect && limitInput) {
                const betType = parseInt(betSelect.value, 10);
                const betName = betSelect.options[betSelect.selectedIndex].text;
                const limit = parseInt(limitInput.value, 10) || 10000;
                stateManager.runCalculation(betType, betName, limit);
            }
        }
        if (e.target.id === 'run-dutching-analysis-btn') {
            const strategieSelect = document.getElementById('dutching-strategie-select');
            if (strategieSelect) {
                const strategie = parseInt(strategieSelect.value, 10);
                stateManager.runDutchingPrediction(strategie);
            }
        }
        if (e.target.closest('#calculate-distribution-btn')) {
            stateManager.calculateBettingDistribution();
        }
    });

    addListener('nbCombinaison', 'change', e => {
        const betSelect = e.target;
        const betType = parseInt(betSelect.value, 10);
        const betName = betSelect.options[betSelect.selectedIndex].text;
        stateManager.setState({ 
            results: { ...stateManager.getState().results, betType, betName, combinations: [] },
            dutchingPrediction: null 
        });
    });

    const filtersContent = document.getElementById('filters-content');
    if (filtersContent) {
        filtersContent.addEventListener('change', e => {
            const distributionUI = e.target.closest('#dutching-application-ui');
            if (distributionUI) {
                if (e.target.id === 'distribution-mode-select') {
                    stateManager.updateBettingDistribution({ mode: e.target.value });
                }
            }
        });
         filtersContent.addEventListener('input', e => {
            const distributionUI = e.target.closest('#dutching-application-ui');
            if (distributionUI) {
                 if (e.target.id === 'distribution-value-input') {
                    stateManager.updateBettingDistribution({ value: parseFloat(e.target.value) || 0 });
                }
            }
        });
    }

    const functionsList = document.getElementById('functions-list');
    if (functionsList) {
        functionsList.addEventListener('input', e => {
            const target = e.target;
            if (target.tagName !== 'SELECT' && target.type !== 'checkbox') return;

            const item = target.closest('.function-item[data-index]');
            if (!item) return;
            const index = parseInt(item.dataset.index, 10);
            const field = target.dataset.field;
            const value = target.type === 'checkbox' ? target.checked : target.value;
            stateManager.updateFilter(index, field, value);
        });

        functionsList.addEventListener('change', e => {
            const target = e.target;
            if (target.tagName !== 'INPUT' || target.type === 'checkbox') return;

            const item = target.closest('.function-item[data-index]');
            if (!item) return;
            const index = parseInt(item.dataset.index, 10);
            const field = target.dataset.field;
            const value = target.value;
            stateManager.updateFilter(index, field, value);
        });

        functionsList.addEventListener('click', e => {
            const item = e.target.closest('.function-item[data-index]');
            if (!item) return;
            const index = parseInt(item.dataset.index, 10);
            if (e.target.closest('.delete-btn')) {
                stateManager.deleteFilter(index); return;
            }
            if (e.target.closest('.spinner-btn')) {
                const input = e.target.parentElement.querySelector('input[type="number"]');
                if (input) {
                    let value = parseInt(input.value, 10) || 0;
                    value += e.target.classList.contains('plus') ? 1 : -1;
                    input.value = Math.max(0, value);
                    stateManager.updateFilter(index, input.dataset.field, input.value);
                }
                return;
            }
            if (e.target.closest('.function-header') && !e.target.closest('.function-header-actions')) {
                stateManager.toggleFilterCollapsed(index);
            }
        });
    }
    
    addListener('champReduitToggle', 'change', e => stateManager.toggleChampReduit(e.target.checked));

    const modal = document.getElementById('filter-action-modal');
    if (modal) {
        modal.addEventListener('click', e => {
            if (e.target === modal || e.target.closest('#modal-cancel-btn')) hideFilterActionModal();
            else if (e.target.closest('#modal-create-vect-btn')) handleCreateFilterFromModal('VECT');
            else if (e.target.closest('#modal-create-order-btn')) handleCreateFilterFromModal('ORDER');
            else if (e.target.closest('#modal-create-som-btn')) handleCreateFilterFromModal('SOM');
            else if (e.target.closest('#modal-create-gap-btn')) handleCreateFilterFromModal('GAP');
        });
    }
    const criteriaModal = document.getElementById('criteria-profile-modal');
    if (criteriaModal) {
        criteriaModal.addEventListener('click', e => {
            if (e.target.closest('#modal-cancel-profile-btn')) stateManager.closeCriteriaModal();
            else if (e.target.closest('#modal-save-profile-btn')) stateManager.saveCriteriaProfile();
            else if (e.target.closest('#modal-apply-profile-btn')) stateManager.applyCriteriaProfile();
            else if (e.target.closest('#modal-delete-profile-btn')) stateManager.deleteCriteriaProfile();
        });
        criteriaModal.addEventListener('change', e => {
            if (e.target.id === 'profile-select') stateManager.selectProfileInModal(e.target.value);
            if (e.target.closest('#criteria-profile-list') && e.target.type === 'checkbox') {
                const newSelectedKeys = Array.from(
                    criteriaModal.querySelectorAll('#criteria-profile-list input[type="checkbox"]:checked')
                ).map(checkbox => checkbox.dataset.criteriaKey).filter(Boolean);
                stateManager.updateCriteriaModal({ selectedKeys: newSelectedKeys });
            }
        });
        criteriaModal.addEventListener('input', e => {
            if (e.target.id === 'profile-name-input') stateManager.updateCriteriaModal({ currentName: e.target.value });
        });
    }

    addListener('strategie-notes', 'change', e => stateManager.saveNoteForCurrentRace(e.target.value));
    addListener('import-strategie-input', 'change', e => {
        if (e.target.files.length > 0) {
            stateManager.importStrategy(e.target.files[0]);
            e.target.value = null; 
        }
    });

    document.body.addEventListener('click', e => {
        if (e.target.closest('#export-strategie-btn')) stateManager.exportStrategy();
        if (e.target.closest('#import-strategie-btn')) document.getElementById('import-strategie-input')?.click();
        if (e.target.id === 'saveFilterSetBtn') {
            const name = prompt("Nom de l'ensemble de filtres :");
            if (name) stateManager.saveCurrentFilterSet(name);
        }
        if (e.target.id === 'deleteFilterSetBtn') {
            const state = stateManager.getState();
            if (state.selectedFilterSetId) stateManager.deleteFilterSet(state.selectedFilterSetId);
        }
    });
    document.body.addEventListener('change', e => {
        if (e.target.id === 'filterSetSelect') {
            stateManager.applyFilterSet(e.target.value);
        }
    });
}
Fichier complet : frontend/style.css (Ajoutez ceci à la toute fin)
code
CSS
/* Styles pour l'Optimiseur Dutching Compact */
.dutching-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.dutching-controls-compact {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 10px;
}

.dutching-controls-compact select {
    height: 48px;
    padding: 0 12px;
}
.dutching-controls-compact button {
    height: 48px;
    padding: 0 20px;
    background-color: var(--success-color);
}

.dutching-result-card {
    background-color: var(--card-bg-color);
    border-radius: var(--border-radius);
    padding: 12px;
    border-left: 5px solid var(--dark-gray);
    box-shadow: var(--shadow);
}

.dutching-decision {
    font-size: 1.1em;
    font-weight: 700;
    text-align: center;
}

.dutching-applier-container {
    margin-top: 5px;
    padding: 15px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.horse-chips-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
}

.horse-chip {
    background-color: var(--info-bg-color);
    color: var(--text-color);
    padding: 5px 12px;
    border-radius: 15px;
    font-size: 0.9em;
    font-weight: 600;
}

.dutching-controls {
    display: grid;
    grid-template-columns: 1fr 100px 50px; /* Colonnes ajustées */
    gap: 8px;
    align-items: center;
}

.dutching-controls select, .dutching-controls input, .dutching-controls button {
    height: 44px;
    padding: 0 10px;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    background-color: var(--input-bg-color);
    color: var(--text-color);
    font-size: 1em;
    box-sizing: border-box;
}

.dutching-controls input[type="number"] {
    text-align: center;
    -moz-appearance: textfield;
}
.dutching-controls input::-webkit-outer-spin-button,
.dutching-controls input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.dutching-controls button {
    background-color: var(--success-color);
    color: white;
    padding: 0;
}

.distribution-results-table td:nth-child(1) {
    font-weight: 700;
}